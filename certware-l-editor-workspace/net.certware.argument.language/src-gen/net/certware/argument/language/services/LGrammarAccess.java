/*
 * generated by Xtext
 */
package net.certware.argument.language.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Program");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//// basic model is the program of section 1.13
		//Program:
		//	statements+=Statement*;
		@Override public ParserRule getRule() { return rule; }

		//statements+=Statement*
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}

	public class BasicTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.BasicTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypedVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArithmeticTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionalTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// 1.1 Symbols
		////Symbol:
		////	IntegerNumeral |
		////	Identifier |
		////	SpecialCharacter
		////;
		//// IntegerNumeral:  MRB replaced with direct substitution of terminal INT
		////	INT // provided by Terminals and returning ECore Integer type 
		//// ;
		//// Identifier:  MRB replaced with direct substitution of terminal ID
		////	ID // provided by Terminals and returning ECore String type
		////;
		////SpecialCharacter:
		////	'>' | '=' | '<' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
		////;
		//// 1.2 Basic Terms, 1.14.1 Terms
		//BasicTerm:
		//	TypedVariable | ArithmeticTerm | FunctionalTerm // ID ( BasicTerms )
		//;
		@Override public ParserRule getRule() { return rule; }

		//// NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//TypedVariable | ArithmeticTerm | FunctionalTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//// NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//TypedVariable
		public RuleCall getTypedVariableParserRuleCall_0() { return cTypedVariableParserRuleCall_0; }

		//// ID UID
		//ArithmeticTerm
		public RuleCall getArithmeticTermParserRuleCall_1() { return cArithmeticTermParserRuleCall_1; }

		//// Addition | Multiplication
		//FunctionalTerm
		public RuleCall getFunctionalTermParserRuleCall_2() { return cFunctionalTermParserRuleCall_2; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Variable");
		private final Assignment cIdentifierAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdentifierUIDTerminalRuleCall_0 = (RuleCall)cIdentifierAssignment.eContents().get(0);
		
		//Variable:
		//	identifier=UID;
		@Override public ParserRule getRule() { return rule; }

		//identifier=UID
		public Assignment getIdentifierAssignment() { return cIdentifierAssignment; }

		//UID
		public RuleCall getIdentifierUIDTerminalRuleCall_0() { return cIdentifierUIDTerminalRuleCall_0; }
	}

	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.TypedVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameLIDTerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarVariableParserRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		//TypedVariable:
		//	name=LID var=Variable;
		@Override public ParserRule getRule() { return rule; }

		//name=LID var=Variable
		public Group getGroup() { return cGroup; }

		//name=LID
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }

		//LID
		public RuleCall getNameLIDTerminalRuleCall_0_0() { return cNameLIDTerminalRuleCall_0_0; }

		//var=Variable
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_1_0() { return cVarVariableParserRuleCall_1_0; }
	}

	public class ArithmeticTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.ArithmeticTerm");
		private final RuleCall cAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// our version of a left-factored equivalent of the recursive grammar from the spec
		//ArithmeticTerm:
		//	Addition;
		@Override public ParserRule getRule() { return rule; }

		//Addition
		public RuleCall getAdditionParserRuleCall() { return cAdditionParserRuleCall; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Addition ArithmeticTerm:
		//	Multiplication ({Addition.lhs=current} ('+' | '-') rhs=Multiplication)*
		@Override public ParserRule getRule() { return rule; }

		//Multiplication ({Addition.lhs=current} ('+' | '-') rhs=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({Addition.lhs=current} ('+' | '-') rhs=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Addition.lhs=current}
		public Action getAdditionLhsAction_1_0() { return cAdditionLhsAction_1_0; }

		//('+' | '-')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//'+'
		public Keyword getPlusSignKeyword_1_1_0() { return cPlusSignKeyword_1_1_0; }

		//'-'
		public Keyword getHyphenMinusKeyword_1_1_1() { return cHyphenMinusKeyword_1_1_1; }

		//rhs=Multiplication
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Multiplication
		public RuleCall getRhsMultiplicationParserRuleCall_1_2_0() { return cRhsMultiplicationParserRuleCall_1_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cPercentSignKeyword_1_1_2 = (Keyword)cAlternatives_1_1.eContents().get(2);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsPrimaryParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Multiplication ArithmeticTerm:
		//	Primary ({Multiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
		@Override public ParserRule getRule() { return rule; }

		//Primary ({Multiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({Multiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multiplication.lhs=current}
		public Action getMultiplicationLhsAction_1_0() { return cMultiplicationLhsAction_1_0; }

		//('*' | '/' | '%')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//'*'
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//'/'
		public Keyword getSolidusKeyword_1_1_1() { return cSolidusKeyword_1_1_1; }

		//'%'
		public Keyword getPercentSignKeyword_1_1_2() { return cPercentSignKeyword_1_1_2; }

		//rhs=Primary
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Primary
		public RuleCall getRhsPrimaryParserRuleCall_1_2_0() { return cRhsPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTermAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTermArithmeticLiteralParserRuleCall_0_0 = (RuleCall)cTermAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermAdditionParserRuleCall_1_1_0 = (RuleCall)cTermAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//// Vu: removed explicitly negative arithmetic expressions
		//Primary ArithmeticTerm:
		//	term=ArithmeticLiteral |
		//	/ *(minus='-')?* / '(' term=Addition ')'
		@Override public ParserRule getRule() { return rule; }

		/// *(minus='-')?* / term=ArithmeticLiteral | / *(minus='-')?* / '(' term=Addition ')'
		public Alternatives getAlternatives() { return cAlternatives; }

		/// *(minus='-')?* / term=ArithmeticLiteral
		public Assignment getTermAssignment_0() { return cTermAssignment_0; }

		//ArithmeticLiteral
		public RuleCall getTermArithmeticLiteralParserRuleCall_0_0() { return cTermArithmeticLiteralParserRuleCall_0_0; }

		/// *(minus='-')?* / '(' term=Addition ')'
		public Group getGroup_1() { return cGroup_1; }

		/// *(minus='-')?* / '('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//term=Addition
		public Assignment getTermAssignment_1_1() { return cTermAssignment_1_1; }

		//Addition
		public RuleCall getTermAdditionParserRuleCall_1_1_0() { return cTermAdditionParserRuleCall_1_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class ArithmeticLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.ArithmeticLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVVariableParserRuleCall_0_0 = (RuleCall)cVAssignment_0.eContents().get(0);
		private final Assignment cTvAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTvTypedVariableParserRuleCall_1_0 = (RuleCall)cTvAssignment_1.eContents().get(0);
		private final Assignment cConstAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cConstLIDTerminalRuleCall_2_0 = (RuleCall)cConstAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueNUMERIC_CONSTANTTerminalRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ArithmeticLiteral:
		//	v=Variable | tv=TypedVariable | const=LID | value=NUMERIC_CONSTANT;
		@Override public ParserRule getRule() { return rule; }

		//v=Variable | tv=TypedVariable | const=LID | value=NUMERIC_CONSTANT
		public Alternatives getAlternatives() { return cAlternatives; }

		//v=Variable
		public Assignment getVAssignment_0() { return cVAssignment_0; }

		//Variable
		public RuleCall getVVariableParserRuleCall_0_0() { return cVVariableParserRuleCall_0_0; }

		//// UID
		//tv=TypedVariable
		public Assignment getTvAssignment_1() { return cTvAssignment_1; }

		//TypedVariable
		public RuleCall getTvTypedVariableParserRuleCall_1_0() { return cTvTypedVariableParserRuleCall_1_0; }

		//const=LID
		public Assignment getConstAssignment_2() { return cConstAssignment_2; }

		//LID
		public RuleCall getConstLIDTerminalRuleCall_2_0() { return cConstLIDTerminalRuleCall_2_0; }

		////CONST
		//value=NUMERIC_CONSTANT
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//NUMERIC_CONSTANT
		public RuleCall getValueNUMERIC_CONSTANTTerminalRuleCall_3_0() { return cValueNUMERIC_CONSTANTTerminalRuleCall_3_0; }
	}

	public class GroundArithmeticTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundArithmeticTerm");
		private final RuleCall cGroundAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// ground arithmetic term from 1.2 and  1.14.1, 
		//// reuse the definition of Arithmetic Term
		//GroundArithmeticTerm:
		//	GroundAddition;
		@Override public ParserRule getRule() { return rule; }

		//GroundAddition
		public RuleCall getGroundAdditionParserRuleCall() { return cGroundAdditionParserRuleCall; }
	}

	public class GroundAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGroundMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cGroundAdditionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsGroundMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//GroundAddition ArithmeticTerm:
		//	GroundMultiplication ({GroundAddition.lhs=current} ('+' | '-') rhs=GroundMultiplication)*
		@Override public ParserRule getRule() { return rule; }

		//GroundMultiplication ({GroundAddition.lhs=current} ('+' | '-') rhs=GroundMultiplication)*
		public Group getGroup() { return cGroup; }

		//GroundMultiplication
		public RuleCall getGroundMultiplicationParserRuleCall_0() { return cGroundMultiplicationParserRuleCall_0; }

		//({GroundAddition.lhs=current} ('+' | '-') rhs=GroundMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{GroundAddition.lhs=current}
		public Action getGroundAdditionLhsAction_1_0() { return cGroundAdditionLhsAction_1_0; }

		//('+' | '-')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//'+'
		public Keyword getPlusSignKeyword_1_1_0() { return cPlusSignKeyword_1_1_0; }

		//'-'
		public Keyword getHyphenMinusKeyword_1_1_1() { return cHyphenMinusKeyword_1_1_1; }

		//rhs=GroundMultiplication
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//GroundMultiplication
		public RuleCall getRhsGroundMultiplicationParserRuleCall_1_2_0() { return cRhsGroundMultiplicationParserRuleCall_1_2_0; }
	}

	public class GroundMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGroundPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cGroundMultiplicationLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cPercentSignKeyword_1_1_2 = (Keyword)cAlternatives_1_1.eContents().get(2);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsPrimaryParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//GroundMultiplication ArithmeticTerm:
		//	GroundPrimary ({GroundMultiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
		@Override public ParserRule getRule() { return rule; }

		//GroundPrimary ({GroundMultiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
		public Group getGroup() { return cGroup; }

		//GroundPrimary
		public RuleCall getGroundPrimaryParserRuleCall_0() { return cGroundPrimaryParserRuleCall_0; }

		//({GroundMultiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{GroundMultiplication.lhs=current}
		public Action getGroundMultiplicationLhsAction_1_0() { return cGroundMultiplicationLhsAction_1_0; }

		//('*' | '/' | '%')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//'*'
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//'/'
		public Keyword getSolidusKeyword_1_1_1() { return cSolidusKeyword_1_1_1; }

		//'%'
		public Keyword getPercentSignKeyword_1_1_2() { return cPercentSignKeyword_1_1_2; }

		//rhs=Primary
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Primary
		public RuleCall getRhsPrimaryParserRuleCall_1_2_0() { return cRhsPrimaryParserRuleCall_1_2_0; }
	}

	public class GroundPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cTermAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cTermGroundArithmeticLiteralParserRuleCall_0_0 = (RuleCall)cTermAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermAdditionParserRuleCall_1_1_0 = (RuleCall)cTermAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//GroundPrimary ArithmeticTerm:
		//	term=GroundArithmeticLiteral |
		//	/ *(minus='-')?* / '(' term=Addition ')'
		@Override public ParserRule getRule() { return rule; }

		/// *(minus='-')?* / term=GroundArithmeticLiteral | / *(minus='-')?* / '(' term=Addition ')'
		public Alternatives getAlternatives() { return cAlternatives; }

		/// *(minus='-')?* / term=GroundArithmeticLiteral
		public Assignment getTermAssignment_0() { return cTermAssignment_0; }

		//GroundArithmeticLiteral
		public RuleCall getTermGroundArithmeticLiteralParserRuleCall_0_0() { return cTermGroundArithmeticLiteralParserRuleCall_0_0; }

		/// *(minus='-')?* / '(' term=Addition ')'
		public Group getGroup_1() { return cGroup_1; }

		/// *(minus='-')?* / '('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//term=Addition
		public Assignment getTermAssignment_1_1() { return cTermAssignment_1_1; }

		//Addition
		public RuleCall getTermAdditionParserRuleCall_1_1_0() { return cTermAdditionParserRuleCall_1_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class GroundArithmeticLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundArithmeticLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIdentifierAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIdentifierLIDTerminalRuleCall_0_0 = (RuleCall)cIdentifierAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueNUMERIC_CONSTANTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//GroundArithmeticLiteral:
		//	identifier=LID | value=NUMERIC_CONSTANT;
		@Override public ParserRule getRule() { return rule; }

		//identifier=LID | value=NUMERIC_CONSTANT
		public Alternatives getAlternatives() { return cAlternatives; }

		//identifier=LID
		public Assignment getIdentifierAssignment_0() { return cIdentifierAssignment_0; }

		//LID
		public RuleCall getIdentifierLIDTerminalRuleCall_0_0() { return cIdentifierLIDTerminalRuleCall_0_0; }

		//value=NUMERIC_CONSTANT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//NUMERIC_CONSTANT
		public RuleCall getValueNUMERIC_CONSTANTTerminalRuleCall_1_0() { return cValueNUMERIC_CONSTANTTerminalRuleCall_1_0; }
	}

	public class FunctionalTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.FunctionalTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cTermsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionalTerm:
		//	LID '(' Terms ')';
		@Override public ParserRule getRule() { return rule; }

		//// ID'('terms+=BasicTerm+')'
		//LID '(' Terms ')'
		public Group getGroup() { return cGroup; }

		//// ID'('terms+=BasicTerm+')'
		//LID
		public RuleCall getLIDTerminalRuleCall_0() { return cLIDTerminalRuleCall_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//Terms
		public RuleCall getTermsParserRuleCall_2() { return cTermsParserRuleCall_2; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class GroundFunctionalTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundFunctionalTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cGroundTermsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//GroundFunctionalTerm:
		//	LID '(' GroundTerms ')';
		@Override public ParserRule getRule() { return rule; }

		//// ID'('terms+=BasicTerm+')'
		//LID '(' GroundTerms ')'
		public Group getGroup() { return cGroup; }

		//// ID'('terms+=BasicTerm+')'
		//LID
		public RuleCall getLIDTerminalRuleCall_0() { return cLIDTerminalRuleCall_0; }

		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//GroundTerms
		public RuleCall getGroundTermsParserRuleCall_2() { return cGroundTermsParserRuleCall_2; }

		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class BasicTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.BasicTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarBasicTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrBasicTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//BasicTerms:
		//	car=BasicTerm (',' cdr+=BasicTerm)*;
		@Override public ParserRule getRule() { return rule; }

		//car=BasicTerm (',' cdr+=BasicTerm)*
		public Group getGroup() { return cGroup; }

		//car=BasicTerm
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//BasicTerm
		public RuleCall getCarBasicTermParserRuleCall_0_0() { return cCarBasicTermParserRuleCall_0_0; }

		//(',' cdr+=BasicTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=BasicTerm
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//BasicTerm
		public RuleCall getCdrBasicTermParserRuleCall_1_1_0() { return cCdrBasicTermParserRuleCall_1_1_0; }
	}

	public class GroundTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarGroundTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrGroundTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//GroundTerms:
		//	car=GroundTerm (',' cdr+=GroundTerm)*;
		@Override public ParserRule getRule() { return rule; }

		//car=GroundTerm (',' cdr+=GroundTerm)*
		public Group getGroup() { return cGroup; }

		//car=GroundTerm
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//GroundTerm
		public RuleCall getCarGroundTermParserRuleCall_0_0() { return cCarGroundTermParserRuleCall_0_0; }

		//(',' cdr+=GroundTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=GroundTerm
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//GroundTerm
		public RuleCall getCdrGroundTermParserRuleCall_1_1_0() { return cCdrGroundTermParserRuleCall_1_1_0; }
	}

	public class GroundTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.GroundTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGroundArithmeticTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGroundFunctionalTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GroundTerm:
		//	GroundArithmeticTerm | GroundFunctionalTerm;
		@Override public ParserRule getRule() { return rule; }

		//GroundArithmeticTerm | GroundFunctionalTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//GroundArithmeticTerm
		public RuleCall getGroundArithmeticTermParserRuleCall_0() { return cGroundArithmeticTermParserRuleCall_0; }

		//GroundFunctionalTerm
		public RuleCall getGroundFunctionalTermParserRuleCall_1() { return cGroundFunctionalTermParserRuleCall_1; }
	}

	public class QuantifiedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.QuantifiedTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUniversalQuantifiedTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistentialQuantifiedTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// 1.6 Quantified Terms, 1.14.1 Terms
		//QuantifiedTerm:
		//	UniversalQuantifiedTerm | ExistentialQuantifiedTerm;
		@Override public ParserRule getRule() { return rule; }

		//// Quantifier LID (Variable)?  mrb changed to scope on type ID
		//// Quantifier id=[TypeId] (var=Variable)? // okay with Quantifier rule
		//// ('every' name=[TypeId]) | 
		//// ('some' name=[TVar])
		//UniversalQuantifiedTerm | ExistentialQuantifiedTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//// Quantifier LID (Variable)?  mrb changed to scope on type ID
		//// Quantifier id=[TypeId] (var=Variable)? // okay with Quantifier rule
		//// ('every' name=[TypeId]) | 
		//// ('some' name=[TVar])
		//UniversalQuantifiedTerm
		public RuleCall getUniversalQuantifiedTermParserRuleCall_0() { return cUniversalQuantifiedTermParserRuleCall_0; }

		//ExistentialQuantifiedTerm
		public RuleCall getExistentialQuantifiedTermParserRuleCall_1() { return cExistentialQuantifiedTermParserRuleCall_1; }
	}

	public class UniversalQuantifiedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.UniversalQuantifiedTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEveryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameTypeIdParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//// Vu: forbid `predicateName(quantifier typeName VarName)
		//UniversalQuantifiedTerm:
		//	'every' name=TypeId;
		@Override public ParserRule getRule() { return rule; }

		//'every' name=TypeId
		public Group getGroup() { return cGroup; }

		//'every'
		public Keyword getEveryKeyword_0() { return cEveryKeyword_0; }

		//name=TypeId
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//TypeId
		public RuleCall getNameTypeIdParserRuleCall_1_0() { return cNameTypeIdParserRuleCall_1_0; }
	}

	public class ExistentialQuantifiedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.ExistentialQuantifiedTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSomeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameTypeIdParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		
		//ExistentialQuantifiedTerm:
		//	'some' name=TypeId;
		@Override public ParserRule getRule() { return rule; }

		//'some' name=TypeId
		public Group getGroup() { return cGroup; }

		//'some'
		public Keyword getSomeKeyword_0() { return cSomeKeyword_0; }

		//name=TypeId
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//TypeId
		public RuleCall getNameTypeIdParserRuleCall_1_0() { return cNameTypeIdParserRuleCall_1_0; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifiedTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////Quantifier:
		////	mrb removed for explicit scope disambiguation in QuantifiedTerm rule above
		////	'every' | 'some';
		//// 1.7 Terms, 1.14.1 Terms
		//Term:
		//	BasicTerm | QuantifiedTerm;
		@Override public ParserRule getRule() { return rule; }

		//BasicTerm | QuantifiedTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicTerm
		public RuleCall getBasicTermParserRuleCall_0() { return cBasicTermParserRuleCall_0; }

		//QuantifiedTerm
		public RuleCall getQuantifiedTermParserRuleCall_1() { return cQuantifiedTermParserRuleCall_1; }
	}

	public class TermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Terms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//Terms:
		//	car=Term (',' cdr+=Term)*;
		@Override public ParserRule getRule() { return rule; }

		//car=Term (',' cdr+=Term)*
		public Group getGroup() { return cGroup; }

		//car=Term
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//Term
		public RuleCall getCarTermParserRuleCall_0_0() { return cCarTermParserRuleCall_0_0; }

		//(',' cdr+=Term)*
		public Group getGroup_1() { return cGroup_1; }

		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=Term
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//Term
		public RuleCall getCdrTermParserRuleCall_1_1_0() { return cCdrTermParserRuleCall_1_1_0; }
	}

	public class ConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.ConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameLIDTerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCvAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCvGroundArithmeticTermParserRuleCall_3_0 = (RuleCall)cCvAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// 1.14.2, 1.3 Constant Declaration
		//ConstantDeclaration:
		//	'const' name=LID
		//	'='
		//	// (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//	cv=GroundArithmeticTerm
		//	'.';
		@Override public ParserRule getRule() { return rule; }

		//'const' name=LID '=' // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//cv=GroundArithmeticTerm '.'
		public Group getGroup() { return cGroup; }

		//'const'
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }

		//name=LID
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//LID
		public RuleCall getNameLIDTerminalRuleCall_1_0() { return cNameLIDTerminalRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//// (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//cv=GroundArithmeticTerm
		public Assignment getCvAssignment_3() { return cCvAssignment_3; }

		//GroundArithmeticTerm
		public RuleCall getCvGroundArithmeticTermParserRuleCall_3_0() { return cCvGroundArithmeticTermParserRuleCall_3_0; }

		//'.'
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}

	public class TypeIdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.TypeId");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameLIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//// 1.5 Type Declarations, 1.14.3 Type Declarations
		//// mrb added type ID so we can use it in scoping rules
		//TypeId:
		//	name=LID;
		@Override public ParserRule getRule() { return rule; }

		//name=LID
		public Assignment getNameAssignment() { return cNameAssignment; }

		//LID
		public RuleCall getNameLIDTerminalRuleCall_0() { return cNameLIDTerminalRuleCall_0; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameTypeIdParserRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpSetExpressionParserRuleCall_3_0 = (RuleCall)cExpAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TypeDeclaration:
		//	'type' name=TypeId '=' exp=SetExpression '.';
		@Override public ParserRule getRule() { return rule; }

		//'type' name=TypeId '=' exp=SetExpression '.'
		public Group getGroup() { return cGroup; }

		//'type'
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//name=TypeId
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }

		//TypeId
		public RuleCall getNameTypeIdParserRuleCall_1_0() { return cNameTypeIdParserRuleCall_1_0; }

		//'='
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//exp=SetExpression
		public Assignment getExpAssignment_3() { return cExpAssignment_3; }

		//SetExpression
		public RuleCall getExpSetExpressionParserRuleCall_3_0() { return cExpSetExpressionParserRuleCall_3_0; }

		//'.'
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}

	public class LimitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Limit");
		private final Assignment cCvAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCvGroundArithmeticTermParserRuleCall_0 = (RuleCall)cCvAssignment.eContents().get(0);
		
		//Limit:
		//	cv=GroundArithmeticTerm;
		@Override public ParserRule getRule() { return rule; }

		////id=ID | 
		//// nc=NumericConstant | at=ArithmeticTerm
		//cv=GroundArithmeticTerm
		public Assignment getCvAssignment() { return cCvAssignment; }

		//GroundArithmeticTerm
		public RuleCall getCvGroundArithmeticTermParserRuleCall_0() { return cCvGroundArithmeticTermParserRuleCall_0; }
	}

	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Set");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cLhsLeftCurlyBracketKeyword_0_0 = (Keyword)cLhsAssignment_0.eContents().get(0);
		private final Assignment cTermsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermsGroundTermsParserRuleCall_1_0 = (RuleCall)cTermsAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Vu: forbid empty type
		//Set:
		//	lhs='{' terms=GroundTerms '}';
		@Override public ParserRule getRule() { return rule; }

		//lhs='{' terms=GroundTerms '}'
		public Group getGroup() { return cGroup; }

		//lhs='{'
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//'{'
		public Keyword getLhsLeftCurlyBracketKeyword_0_0() { return cLhsLeftCurlyBracketKeyword_0_0; }

		//terms=GroundTerms
		public Assignment getTermsAssignment_1() { return cTermsAssignment_1; }

		//GroundTerms
		public RuleCall getTermsGroundTermsParserRuleCall_1_0() { return cTermsGroundTermsParserRuleCall_1_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLhsLimitParserRuleCall_1_0 = (RuleCall)cLhsAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRhsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRhsLimitParserRuleCall_4_0 = (RuleCall)cRhsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Range:
		//	'{' lhs=Limit '.' '.' rhs=Limit '}';
		@Override public ParserRule getRule() { return rule; }

		//'{' lhs=Limit '.' '.' rhs=Limit '}'
		public Group getGroup() { return cGroup; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//lhs=Limit
		public Assignment getLhsAssignment_1() { return cLhsAssignment_1; }

		//Limit
		public RuleCall getLhsLimitParserRuleCall_1_0() { return cLhsLimitParserRuleCall_1_0; }

		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }

		//'.'
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }

		//rhs=Limit
		public Assignment getRhsAssignment_4() { return cRhsAssignment_4; }

		//Limit
		public RuleCall getRhsLimitParserRuleCall_4_0() { return cRhsLimitParserRuleCall_4_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class SetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SetExpression");
		private final RuleCall cSetAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SetExpression:
		//	SetAddition // | SetMultiplication
		//;
		@Override public ParserRule getRule() { return rule; }

		//SetAddition
		public RuleCall getSetAdditionParserRuleCall() { return cSetAdditionParserRuleCall; }
	}

	public class SetConstructElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SetConstruct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBasicTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cWhereKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsTVarsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//SetConstruct:
		//	lhs=BasicTerm 'where' rhs=TVars;
		@Override public ParserRule getRule() { return rule; }

		//lhs=BasicTerm 'where' rhs=TVars
		public Group getGroup() { return cGroup; }

		//lhs=BasicTerm
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//BasicTerm
		public RuleCall getLhsBasicTermParserRuleCall_0_0() { return cLhsBasicTermParserRuleCall_0_0; }

		//'where'
		public Keyword getWhereKeyword_1() { return cWhereKeyword_1; }

		//rhs=TVars
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//TVars
		public RuleCall getRhsTVarsParserRuleCall_2_0() { return cRhsTVarsParserRuleCall_2_0; }
	}

	public class TVarsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.TVars");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarTVarParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrTVarParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//TVars:
		//	car=TVar (',' cdr+=TVar)*;
		@Override public ParserRule getRule() { return rule; }

		//car=TVar (',' cdr+=TVar)*
		public Group getGroup() { return cGroup; }

		//car=TVar
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//TVar
		public RuleCall getCarTVarParserRuleCall_0_0() { return cCarTVarParserRuleCall_0_0; }

		//(',' cdr+=TVar)*
		public Group getGroup_1() { return cGroup_1; }

		//','
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=TVar
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//TVar
		public RuleCall getCdrTVarParserRuleCall_1_1_0() { return cCdrTVarParserRuleCall_1_1_0; }
	}

	public class TVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.TVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarVariableParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIdAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdTypeIdParserRuleCall_2_0 = (RuleCall)cIdAssignment_2.eContents().get(0);
		
		//TVar:
		//	var=Variable 'in' id=TypeId;
		@Override public ParserRule getRule() { return rule; }

		//// var=Variable 'in' id=LID // mrb updated for scope additions
		//var=Variable 'in' id=TypeId
		public Group getGroup() { return cGroup; }

		//// var=Variable 'in' id=LID // mrb updated for scope additions
		//var=Variable
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_0_0() { return cVarVariableParserRuleCall_0_0; }

		//'in'
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//id=TypeId
		public Assignment getIdAssignment_2() { return cIdAssignment_2; }

		//TypeId
		public RuleCall getIdTypeIdParserRuleCall_2_0() { return cIdTypeIdParserRuleCall_2_0; }
	}

	public class SetAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SetAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSetAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSetMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SetAddition SetExpression:
		//	SetMultiplication ({SetAddition.left=current} '+' right=SetMultiplication)*
		@Override public ParserRule getRule() { return rule; }

		//SetMultiplication ({SetAddition.left=current} '+' right=SetMultiplication)*
		public Group getGroup() { return cGroup; }

		//SetMultiplication
		public RuleCall getSetMultiplicationParserRuleCall_0() { return cSetMultiplicationParserRuleCall_0; }

		//({SetAddition.left=current} '+' right=SetMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{SetAddition.left=current}
		public Action getSetAdditionLeftAction_1_0() { return cSetAdditionLeftAction_1_0; }

		//'+'
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=SetMultiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SetMultiplication
		public RuleCall getRightSetMultiplicationParserRuleCall_1_2_0() { return cRightSetMultiplicationParserRuleCall_1_2_0; }
	}

	public class SetMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SetMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSetMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cReverseSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSetPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SetMultiplication SetExpression:
		//	SetPrimary ({SetMultiplication.left=current} ('*' | '\\') right=SetPrimary)*
		@Override public ParserRule getRule() { return rule; }

		//SetPrimary ({SetMultiplication.left=current} ('*' | '\\') right=SetPrimary)*
		public Group getGroup() { return cGroup; }

		//SetPrimary
		public RuleCall getSetPrimaryParserRuleCall_0() { return cSetPrimaryParserRuleCall_0; }

		//({SetMultiplication.left=current} ('*' | '\\') right=SetPrimary)*
		public Group getGroup_1() { return cGroup_1; }

		//{SetMultiplication.left=current}
		public Action getSetMultiplicationLeftAction_1_0() { return cSetMultiplicationLeftAction_1_0; }

		//('*' | '\\')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//'*'
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//'\\'
		public Keyword getReverseSolidusKeyword_1_1_1() { return cReverseSolidusKeyword_1_1_1; }

		//right=SetPrimary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SetPrimary
		public RuleCall getRightSetPrimaryParserRuleCall_1_2_0() { return cRightSetPrimaryParserRuleCall_1_2_0; }
	}

	public class SetPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SetPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSetAdditionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//SetPrimary SetExpression:
		//	SetLiteral | '(' SetAddition ')'
		@Override public ParserRule getRule() { return rule; }

		//SetLiteral | '(' SetAddition ')'
		public Alternatives getAlternatives() { return cAlternatives; }

		//SetLiteral
		public RuleCall getSetLiteralParserRuleCall_0() { return cSetLiteralParserRuleCall_0; }

		//'(' SetAddition ')'
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//SetAddition
		public RuleCall getSetAdditionParserRuleCall_1_1() { return cSetAdditionParserRuleCall_1_1; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class SetLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SetLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRangeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSetConstructParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLIDTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//SetLiteral SetExpression:
		//	Set | Range | SetConstruct | LID
		@Override public ParserRule getRule() { return rule; }

		//Set | Range | SetConstruct | LID
		public Alternatives getAlternatives() { return cAlternatives; }

		//Set
		public RuleCall getSetParserRuleCall_0() { return cSetParserRuleCall_0; }

		//Range
		public RuleCall getRangeParserRuleCall_1() { return cRangeParserRuleCall_1; }

		//SetConstruct
		public RuleCall getSetConstructParserRuleCall_2() { return cSetConstructParserRuleCall_2; }

		//LID
		public RuleCall getLIDTerminalRuleCall_3() { return cLIDTerminalRuleCall_3; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredicateAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBuiltInAtomParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// 1.8 Atoms, 1.14.4 Atoms
		//Atom:
		//	PredicateAtom | BuiltInAtom;
		@Override public ParserRule getRule() { return rule; }

		//PredicateAtom | BuiltInAtom
		public Alternatives getAlternatives() { return cAlternatives; }

		//PredicateAtom
		public RuleCall getPredicateAtomParserRuleCall_0() { return cPredicateAtomParserRuleCall_0; }

		//BuiltInAtom
		public RuleCall getBuiltInAtomParserRuleCall_1() { return cBuiltInAtomParserRuleCall_1; }
	}

	public class PredicateAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.PredicateAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFidAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFidLIDTerminalRuleCall_0_0 = (RuleCall)cFidAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsTermsParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PredicateAtom:
		//	fid=LID ('(' terms=Terms ')')?;
		@Override public ParserRule getRule() { return rule; }

		//fid=LID ('(' terms=Terms ')')?
		public Group getGroup() { return cGroup; }

		//fid=LID
		public Assignment getFidAssignment_0() { return cFidAssignment_0; }

		//LID
		public RuleCall getFidLIDTerminalRuleCall_0_0() { return cFidLIDTerminalRuleCall_0_0; }

		//('(' terms=Terms ')')?
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//terms=Terms
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }

		//Terms
		public RuleCall getTermsTermsParserRuleCall_1_1_0() { return cTermsTermsParserRuleCall_1_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class BasicPredicateAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.BasicPredicateAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFidAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFidLIDTerminalRuleCall_0_0 = (RuleCall)cFidAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsBasicTermsParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BasicPredicateAtom:
		//	fid=LID ('(' terms=BasicTerms ')')?;
		@Override public ParserRule getRule() { return rule; }

		//fid=LID ('(' terms=BasicTerms ')')?
		public Group getGroup() { return cGroup; }

		//fid=LID
		public Assignment getFidAssignment_0() { return cFidAssignment_0; }

		//LID
		public RuleCall getFidLIDTerminalRuleCall_0_0() { return cFidLIDTerminalRuleCall_0_0; }

		//('(' terms=BasicTerms ')')?
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//terms=BasicTerms
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }

		//BasicTerms
		public RuleCall getTermsBasicTermsParserRuleCall_1_1_0() { return cTermsBasicTermsParserRuleCall_1_1_0; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class BuiltInAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.BuiltInAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBasicTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpAtomOpParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsBasicTermParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//BuiltInAtom:
		//	lhs=BasicTerm op=AtomOp rhs=BasicTerm;
		@Override public ParserRule getRule() { return rule; }

		//lhs=BasicTerm op=AtomOp rhs=BasicTerm
		public Group getGroup() { return cGroup; }

		//lhs=BasicTerm
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//BasicTerm
		public RuleCall getLhsBasicTermParserRuleCall_0_0() { return cLhsBasicTermParserRuleCall_0_0; }

		//op=AtomOp
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//AtomOp
		public RuleCall getOpAtomOpParserRuleCall_1_0() { return cOpAtomOpParserRuleCall_1_0; }

		//rhs=BasicTerm
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//BasicTerm
		public RuleCall getRhsBasicTermParserRuleCall_2_0() { return cRhsBasicTermParserRuleCall_2_0; }
	}

	public class BasicAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.BasicAtom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicPredicateAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBuiltInAtomParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BasicAtom:
		//	BasicPredicateAtom | BuiltInAtom;
		@Override public ParserRule getRule() { return rule; }

		//BasicPredicateAtom | BuiltInAtom
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicPredicateAtom
		public RuleCall getBasicPredicateAtomParserRuleCall_0() { return cBasicPredicateAtomParserRuleCall_0; }

		//BuiltInAtom
		public RuleCall getBuiltInAtomParserRuleCall_1() { return cBuiltInAtomParserRuleCall_1; }
	}

	public class AtomOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.AtomOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//AtomOp:
		//	'>' | '<' | '>=' | '<=' | '=' | '!=';
		@Override public ParserRule getRule() { return rule; }

		//'>' | '<' | '>=' | '<=' | '=' | '!='
		public Alternatives getAlternatives() { return cAlternatives; }

		//'>'
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }

		//'<'
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword_2() { return cGreaterThanSignEqualsSignKeyword_2; }

		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//'='
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }
	}

	public class SentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Sentence");
		private final RuleCall cOrSentenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// note <> not used in 1.14.4
		//// Sentences: 1.9. grammar section 1.14.5
		//Sentence:
		//	OrSentence // | AndSentence | NotSentence
		//;
		@Override public ParserRule getRule() { return rule; }

		//OrSentence
		public RuleCall getOrSentenceParserRuleCall() { return cOrSentenceParserRuleCall; }
	}

	public class OrSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.OrSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// our left-factored version of the left-recursive grammar from specification
		//OrSentence SentenceExpr:
		//	AndSentence ({OrSentence.left=current} 'or' right=AndSentence)*
		@Override public ParserRule getRule() { return rule; }

		//AndSentence ({OrSentence.left=current} 'or' right=AndSentence)*
		public Group getGroup() { return cGroup; }

		//AndSentence
		public RuleCall getAndSentenceParserRuleCall_0() { return cAndSentenceParserRuleCall_0; }

		//({OrSentence.left=current} 'or' right=AndSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrSentence.left=current}
		public Action getOrSentenceLeftAction_1_0() { return cOrSentenceLeftAction_1_0; }

		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//right=AndSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndSentence
		public RuleCall getRightAndSentenceParserRuleCall_1_2_0() { return cRightAndSentenceParserRuleCall_1_2_0; }
	}

	public class AndSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.AndSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimarySentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAndKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPrimarySentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndSentence SentenceExpr:
		//	PrimarySentence ({AndSentence.left=current} ('and' | ',') right=PrimarySentence)*
		@Override public ParserRule getRule() { return rule; }

		//PrimarySentence ({AndSentence.left=current} ('and' | ',') right=PrimarySentence)*
		public Group getGroup() { return cGroup; }

		//PrimarySentence
		public RuleCall getPrimarySentenceParserRuleCall_0() { return cPrimarySentenceParserRuleCall_0; }

		//({AndSentence.left=current} ('and' | ',') right=PrimarySentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndSentence.left=current}
		public Action getAndSentenceLeftAction_1_0() { return cAndSentenceLeftAction_1_0; }

		//('and' | ',')
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//'and'
		public Keyword getAndKeyword_1_1_0() { return cAndKeyword_1_1_0; }

		//','
		public Keyword getCommaKeyword_1_1_1() { return cCommaKeyword_1_1_1; }

		//right=PrimarySentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//PrimarySentence
		public RuleCall getRightPrimarySentenceParserRuleCall_1_2_0() { return cRightPrimarySentenceParserRuleCall_1_2_0; }
	}

	public class PrimarySentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.PrimarySentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSentenceLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOrSentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PrimarySentence SentenceExpr:
		//	SentenceLiteral |
		//	'(' OrSentence ')'
		@Override public ParserRule getRule() { return rule; }

		//SentenceLiteral | '(' OrSentence ')'
		public Alternatives getAlternatives() { return cAlternatives; }

		//SentenceLiteral
		public RuleCall getSentenceLiteralParserRuleCall_0() { return cSentenceLiteralParserRuleCall_0; }

		//'(' OrSentence ')'
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//OrSentence
		public RuleCall getOrSentenceParserRuleCall_1_1() { return cOrSentenceParserRuleCall_1_1; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class SentenceLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.SentenceLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cBasicAtomParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//SentenceLiteral:
		//	Atom |
		//	'not' BasicAtom;
		@Override public ParserRule getRule() { return rule; }

		//Atom | 'not' BasicAtom
		public Alternatives getAlternatives() { return cAlternatives; }

		//Atom
		public RuleCall getAtomParserRuleCall_0() { return cAtomParserRuleCall_0; }

		//'not' BasicAtom
		public Group getGroup_1() { return cGroup_1; }

		//'not'
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//BasicAtom
		public RuleCall getBasicAtomParserRuleCall_1_1() { return cBasicAtomParserRuleCall_1_1; }
	}

	public class PSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.pSentence");
		private final RuleCall cPOrSentenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Predicate Sentences 
		//pSentence:
		//	pOrSentence;
		@Override public ParserRule getRule() { return rule; }

		//pOrSentence
		public RuleCall getPOrSentenceParserRuleCall() { return cPOrSentenceParserRuleCall; }
	}

	public class POrSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.pOrSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPAndSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPOrSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPAndSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// our left-factored version of the left-recursive grammar from specification
		//pOrSentence SentenceExpr:
		//	pAndSentence ({pOrSentence.left=current} 'or' right=pAndSentence)*
		@Override public ParserRule getRule() { return rule; }

		//pAndSentence ({pOrSentence.left=current} 'or' right=pAndSentence)*
		public Group getGroup() { return cGroup; }

		//pAndSentence
		public RuleCall getPAndSentenceParserRuleCall_0() { return cPAndSentenceParserRuleCall_0; }

		//({pOrSentence.left=current} 'or' right=pAndSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{pOrSentence.left=current}
		public Action getPOrSentenceLeftAction_1_0() { return cPOrSentenceLeftAction_1_0; }

		//'or'
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//right=pAndSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//pAndSentence
		public RuleCall getRightPAndSentenceParserRuleCall_1_2_0() { return cRightPAndSentenceParserRuleCall_1_2_0; }
	}

	public class PAndSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.pAndSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPPrimarySentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPAndSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPPrimarySentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//pAndSentence SentenceExpr:
		//	pPrimarySentence ({pAndSentence.left=current} 'and' right=pPrimarySentence)*
		@Override public ParserRule getRule() { return rule; }

		//pPrimarySentence ({pAndSentence.left=current} 'and' right=pPrimarySentence)*
		public Group getGroup() { return cGroup; }

		//pPrimarySentence
		public RuleCall getPPrimarySentenceParserRuleCall_0() { return cPPrimarySentenceParserRuleCall_0; }

		//({pAndSentence.left=current} 'and' right=pPrimarySentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{pAndSentence.left=current}
		public Action getPAndSentenceLeftAction_1_0() { return cPAndSentenceLeftAction_1_0; }

		//'and'
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//right=pPrimarySentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//pPrimarySentence
		public RuleCall getRightPPrimarySentenceParserRuleCall_1_2_0() { return cRightPPrimarySentenceParserRuleCall_1_2_0; }
	}

	public class PPrimarySentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.pPrimarySentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPSentenceLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPOrSentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//pPrimarySentence SentenceExpr:
		//	pSentenceLiteral |
		//	'(' pOrSentence ')'
		@Override public ParserRule getRule() { return rule; }

		//pSentenceLiteral | '(' pOrSentence ')'
		public Alternatives getAlternatives() { return cAlternatives; }

		//pSentenceLiteral
		public RuleCall getPSentenceLiteralParserRuleCall_0() { return cPSentenceLiteralParserRuleCall_0; }

		//'(' pOrSentence ')'
		public Group getGroup_1() { return cGroup_1; }

		//'('
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//pOrSentence
		public RuleCall getPOrSentenceParserRuleCall_1_1() { return cPOrSentenceParserRuleCall_1_1; }

		//')'
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class PSentenceLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.pSentenceLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredicateAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cBasicPredicateAtomParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//pSentenceLiteral:
		//	PredicateAtom |
		//	'not' BasicPredicateAtom;
		@Override public ParserRule getRule() { return rule; }

		//PredicateAtom | 'not' BasicPredicateAtom
		public Alternatives getAlternatives() { return cAlternatives; }

		//PredicateAtom
		public RuleCall getPredicateAtomParserRuleCall_0() { return cPredicateAtomParserRuleCall_0; }

		//'not' BasicPredicateAtom
		public Group getGroup_1() { return cGroup_1; }

		//'not'
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//BasicPredicateAtom
		public RuleCall getBasicPredicateAtomParserRuleCall_1_1() { return cBasicPredicateAtomParserRuleCall_1_1; }
	}

	public class MaybeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.MaybeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMaybeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cBasicPredicateAtomParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// 1.10 Maybe Literals, 1.14.5 Maybe Literals
		//MaybeLiteral:
		//	'maybe' BasicPredicateAtom;
		@Override public ParserRule getRule() { return rule; }

		//'maybe' BasicPredicateAtom
		public Group getGroup() { return cGroup; }

		//'maybe'
		public Keyword getMaybeKeyword_0() { return cMaybeKeyword_0; }

		//BasicPredicateAtom
		public RuleCall getBasicPredicateAtomParserRuleCall_1() { return cBasicPredicateAtomParserRuleCall_1; }
	}

	public class CardinalityConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.CardinalityConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBoundParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAtomAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAtomBasicPredicateAtomParserRuleCall_4_0 = (RuleCall)cAtomAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cVerticalLineKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cLessThanSignEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cRhsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cRhsBoundParserRuleCall_8_0 = (RuleCall)cRhsAssignment_8.eContents().get(0);
		
		//// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
		//CardinalityConstraint:
		//	lhs=Bound '<=' '|' '{' atom=BasicPredicateAtom '}' '|' '<=' rhs=Bound;
		@Override public ParserRule getRule() { return rule; }

		//lhs=Bound '<=' '|' '{' atom=BasicPredicateAtom '}' '|' '<=' rhs=Bound
		public Group getGroup() { return cGroup; }

		//lhs=Bound
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//Bound
		public RuleCall getLhsBoundParserRuleCall_0_0() { return cLhsBoundParserRuleCall_0_0; }

		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }

		//'|'
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }

		//'{'
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//atom=BasicPredicateAtom
		public Assignment getAtomAssignment_4() { return cAtomAssignment_4; }

		//BasicPredicateAtom
		public RuleCall getAtomBasicPredicateAtomParserRuleCall_4_0() { return cAtomBasicPredicateAtomParserRuleCall_4_0; }

		//'}'
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }

		//'|'
		public Keyword getVerticalLineKeyword_6() { return cVerticalLineKeyword_6; }

		//'<='
		public Keyword getLessThanSignEqualsSignKeyword_7() { return cLessThanSignEqualsSignKeyword_7; }

		//rhs=Bound
		public Assignment getRhsAssignment_8() { return cRhsAssignment_8; }

		//Bound
		public RuleCall getRhsBoundParserRuleCall_8_0() { return cRhsBoundParserRuleCall_8_0; }
	}

	public class BoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Bound");
		private final Assignment cAvAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cAvArithmeticTermParserRuleCall_0 = (RuleCall)cAvAssignment.eContents().get(0);
		
		//Bound:
		//	av=ArithmeticTerm // | cv=NumericConstant | id=ID
		//;
		@Override public ParserRule getRule() { return rule; }

		//// av=ArithmeticTerm | iv=INT | cv=NumericConstant
		//av=ArithmeticTerm
		public Assignment getAvAssignment() { return cAvAssignment; }

		//ArithmeticTerm
		public RuleCall getAvArithmeticTermParserRuleCall_0() { return cAvArithmeticTermParserRuleCall_0; }
	}

	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadHeadParserRuleCall_0_0 = (RuleCall)cHeadAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cConditionIfKeyword_1_0_0 = (Keyword)cConditionAssignment_1_0.eContents().get(0);
		private final Assignment cBodyAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBodySentenceParserRuleCall_1_1_0 = (RuleCall)cBodyAssignment_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// 1.12 Rules, 1.14.8 Rules
		//Rule:
		//	head=Head (condition='if' body=Sentence)? '.';
		@Override public ParserRule getRule() { return rule; }

		//head=Head (condition='if' body=Sentence)? '.'
		public Group getGroup() { return cGroup; }

		//head=Head
		public Assignment getHeadAssignment_0() { return cHeadAssignment_0; }

		//Head
		public RuleCall getHeadHeadParserRuleCall_0_0() { return cHeadHeadParserRuleCall_0_0; }

		//(condition='if' body=Sentence)?
		public Group getGroup_1() { return cGroup_1; }

		//condition='if'
		public Assignment getConditionAssignment_1_0() { return cConditionAssignment_1_0; }

		//'if'
		public Keyword getConditionIfKeyword_1_0_0() { return cConditionIfKeyword_1_0_0; }

		//body=Sentence
		public Assignment getBodyAssignment_1_1() { return cBodyAssignment_1_1; }

		//Sentence
		public RuleCall getBodySentenceParserRuleCall_1_1_0() { return cBodySentenceParserRuleCall_1_1_0; }

		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}

	public class HeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Head");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPSentenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMaybeLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCardinalityConstraintParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Head:
		//	pSentence | MaybeLiteral | CardinalityConstraint;
		@Override public ParserRule getRule() { return rule; }

		//pSentence | MaybeLiteral | CardinalityConstraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//pSentence
		public RuleCall getPSentenceParserRuleCall_0() { return cPSentenceParserRuleCall_0; }

		//MaybeLiteral
		public RuleCall getMaybeLiteralParserRuleCall_1() { return cMaybeLiteralParserRuleCall_1; }

		//CardinalityConstraint
		public RuleCall getCardinalityConstraintParserRuleCall_2() { return cCardinalityConstraintParserRuleCall_2; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRuleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// 1.13 Program, 1.14.9 Program
		//// by 1.14.9 a program consists of const_decls, type_decls, and rules
		//// these are our statements
		//Statement:
		//	Rule | TypeDeclaration | ConstantDeclaration;
		@Override public ParserRule getRule() { return rule; }

		//Rule | TypeDeclaration | ConstantDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//Rule
		public RuleCall getRuleParserRuleCall_0() { return cRuleParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_2() { return cConstantDeclarationParserRuleCall_2; }
	}
	
	
	private final ProgramElements pProgram;
	private final TerminalRule tLID;
	private final TerminalRule tUID;
	private final BasicTermElements pBasicTerm;
	private final TerminalRule tNUMERIC_CONSTANT;
	private final VariableElements pVariable;
	private final TypedVariableElements pTypedVariable;
	private final ArithmeticTermElements pArithmeticTerm;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final PrimaryElements pPrimary;
	private final ArithmeticLiteralElements pArithmeticLiteral;
	private final GroundArithmeticTermElements pGroundArithmeticTerm;
	private final GroundAdditionElements pGroundAddition;
	private final GroundMultiplicationElements pGroundMultiplication;
	private final GroundPrimaryElements pGroundPrimary;
	private final GroundArithmeticLiteralElements pGroundArithmeticLiteral;
	private final FunctionalTermElements pFunctionalTerm;
	private final GroundFunctionalTermElements pGroundFunctionalTerm;
	private final BasicTermsElements pBasicTerms;
	private final GroundTermsElements pGroundTerms;
	private final GroundTermElements pGroundTerm;
	private final QuantifiedTermElements pQuantifiedTerm;
	private final UniversalQuantifiedTermElements pUniversalQuantifiedTerm;
	private final ExistentialQuantifiedTermElements pExistentialQuantifiedTerm;
	private final TermElements pTerm;
	private final TermsElements pTerms;
	private final ConstantDeclarationElements pConstantDeclaration;
	private final TypeIdElements pTypeId;
	private final TypeDeclarationElements pTypeDeclaration;
	private final LimitElements pLimit;
	private final SetElements pSet;
	private final RangeElements pRange;
	private final SetExpressionElements pSetExpression;
	private final SetConstructElements pSetConstruct;
	private final TVarsElements pTVars;
	private final TVarElements pTVar;
	private final SetAdditionElements pSetAddition;
	private final SetMultiplicationElements pSetMultiplication;
	private final SetPrimaryElements pSetPrimary;
	private final SetLiteralElements pSetLiteral;
	private final AtomElements pAtom;
	private final PredicateAtomElements pPredicateAtom;
	private final BasicPredicateAtomElements pBasicPredicateAtom;
	private final BuiltInAtomElements pBuiltInAtom;
	private final BasicAtomElements pBasicAtom;
	private final AtomOpElements pAtomOp;
	private final SentenceElements pSentence;
	private final OrSentenceElements pOrSentence;
	private final AndSentenceElements pAndSentence;
	private final PrimarySentenceElements pPrimarySentence;
	private final SentenceLiteralElements pSentenceLiteral;
	private final PSentenceElements pPSentence;
	private final POrSentenceElements pPOrSentence;
	private final PAndSentenceElements pPAndSentence;
	private final PPrimarySentenceElements pPPrimarySentence;
	private final PSentenceLiteralElements pPSentenceLiteral;
	private final MaybeLiteralElements pMaybeLiteral;
	private final CardinalityConstraintElements pCardinalityConstraint;
	private final BoundElements pBound;
	private final RuleElements pRule;
	private final HeadElements pHead;
	private final StatementElements pStatement;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.tLID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.LID");
		this.tUID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.UID");
		this.pBasicTerm = new BasicTermElements();
		this.tNUMERIC_CONSTANT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "net.certware.argument.language.L.NUMERIC_CONSTANT");
		this.pVariable = new VariableElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pArithmeticTerm = new ArithmeticTermElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pPrimary = new PrimaryElements();
		this.pArithmeticLiteral = new ArithmeticLiteralElements();
		this.pGroundArithmeticTerm = new GroundArithmeticTermElements();
		this.pGroundAddition = new GroundAdditionElements();
		this.pGroundMultiplication = new GroundMultiplicationElements();
		this.pGroundPrimary = new GroundPrimaryElements();
		this.pGroundArithmeticLiteral = new GroundArithmeticLiteralElements();
		this.pFunctionalTerm = new FunctionalTermElements();
		this.pGroundFunctionalTerm = new GroundFunctionalTermElements();
		this.pBasicTerms = new BasicTermsElements();
		this.pGroundTerms = new GroundTermsElements();
		this.pGroundTerm = new GroundTermElements();
		this.pQuantifiedTerm = new QuantifiedTermElements();
		this.pUniversalQuantifiedTerm = new UniversalQuantifiedTermElements();
		this.pExistentialQuantifiedTerm = new ExistentialQuantifiedTermElements();
		this.pTerm = new TermElements();
		this.pTerms = new TermsElements();
		this.pConstantDeclaration = new ConstantDeclarationElements();
		this.pTypeId = new TypeIdElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pLimit = new LimitElements();
		this.pSet = new SetElements();
		this.pRange = new RangeElements();
		this.pSetExpression = new SetExpressionElements();
		this.pSetConstruct = new SetConstructElements();
		this.pTVars = new TVarsElements();
		this.pTVar = new TVarElements();
		this.pSetAddition = new SetAdditionElements();
		this.pSetMultiplication = new SetMultiplicationElements();
		this.pSetPrimary = new SetPrimaryElements();
		this.pSetLiteral = new SetLiteralElements();
		this.pAtom = new AtomElements();
		this.pPredicateAtom = new PredicateAtomElements();
		this.pBasicPredicateAtom = new BasicPredicateAtomElements();
		this.pBuiltInAtom = new BuiltInAtomElements();
		this.pBasicAtom = new BasicAtomElements();
		this.pAtomOp = new AtomOpElements();
		this.pSentence = new SentenceElements();
		this.pOrSentence = new OrSentenceElements();
		this.pAndSentence = new AndSentenceElements();
		this.pPrimarySentence = new PrimarySentenceElements();
		this.pSentenceLiteral = new SentenceLiteralElements();
		this.pPSentence = new PSentenceElements();
		this.pPOrSentence = new POrSentenceElements();
		this.pPAndSentence = new PAndSentenceElements();
		this.pPPrimarySentence = new PPrimarySentenceElements();
		this.pPSentenceLiteral = new PSentenceLiteralElements();
		this.pMaybeLiteral = new MaybeLiteralElements();
		this.pCardinalityConstraint = new CardinalityConstraintElements();
		this.pBound = new BoundElements();
		this.pRule = new RuleElements();
		this.pHead = new HeadElements();
		this.pStatement = new StatementElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.certware.argument.language.L".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// basic model is the program of section 1.13
	//Program:
	//	statements+=Statement*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//terminal LID:
	//	'a'..'z' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getLIDRule() {
		return tLID;
	} 

	//terminal UID:
	//	'A'..'Z' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getUIDRule() {
		return tUID;
	} 

	//// 1.1 Symbols
	////Symbol:
	////	IntegerNumeral |
	////	Identifier |
	////	SpecialCharacter
	////;
	//// IntegerNumeral:  MRB replaced with direct substitution of terminal INT
	////	INT // provided by Terminals and returning ECore Integer type 
	//// ;
	//// Identifier:  MRB replaced with direct substitution of terminal ID
	////	ID // provided by Terminals and returning ECore String type
	////;
	////SpecialCharacter:
	////	'>' | '=' | '<' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
	////;
	//// 1.2 Basic Terms, 1.14.1 Terms
	//BasicTerm:
	//	TypedVariable | ArithmeticTerm | FunctionalTerm // ID ( BasicTerms )
	//;
	public BasicTermElements getBasicTermAccess() {
		return pBasicTerm;
	}
	
	public ParserRule getBasicTermRule() {
		return getBasicTermAccess().getRule();
	}

	//terminal NUMERIC_CONSTANT:
	//	'0'..'9'+;
	public TerminalRule getNUMERIC_CONSTANTRule() {
		return tNUMERIC_CONSTANT;
	} 

	//Variable:
	//	identifier=UID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//TypedVariable:
	//	name=LID var=Variable;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}

	//// our version of a left-factored equivalent of the recursive grammar from the spec
	//ArithmeticTerm:
	//	Addition;
	public ArithmeticTermElements getArithmeticTermAccess() {
		return pArithmeticTerm;
	}
	
	public ParserRule getArithmeticTermRule() {
		return getArithmeticTermAccess().getRule();
	}

	//Addition ArithmeticTerm:
	//	Multiplication ({Addition.lhs=current} ('+' | '-') rhs=Multiplication)*
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication ArithmeticTerm:
	//	Primary ({Multiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//// Vu: removed explicitly negative arithmetic expressions
	//Primary ArithmeticTerm:
	//	term=ArithmeticLiteral |
	//	/ *(minus='-')?* / '(' term=Addition ')'
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//ArithmeticLiteral:
	//	v=Variable | tv=TypedVariable | const=LID | value=NUMERIC_CONSTANT;
	public ArithmeticLiteralElements getArithmeticLiteralAccess() {
		return pArithmeticLiteral;
	}
	
	public ParserRule getArithmeticLiteralRule() {
		return getArithmeticLiteralAccess().getRule();
	}

	//// ground arithmetic term from 1.2 and  1.14.1, 
	//// reuse the definition of Arithmetic Term
	//GroundArithmeticTerm:
	//	GroundAddition;
	public GroundArithmeticTermElements getGroundArithmeticTermAccess() {
		return pGroundArithmeticTerm;
	}
	
	public ParserRule getGroundArithmeticTermRule() {
		return getGroundArithmeticTermAccess().getRule();
	}

	//GroundAddition ArithmeticTerm:
	//	GroundMultiplication ({GroundAddition.lhs=current} ('+' | '-') rhs=GroundMultiplication)*
	public GroundAdditionElements getGroundAdditionAccess() {
		return pGroundAddition;
	}
	
	public ParserRule getGroundAdditionRule() {
		return getGroundAdditionAccess().getRule();
	}

	//GroundMultiplication ArithmeticTerm:
	//	GroundPrimary ({GroundMultiplication.lhs=current} ('*' | '/' | '%') rhs=Primary)*
	public GroundMultiplicationElements getGroundMultiplicationAccess() {
		return pGroundMultiplication;
	}
	
	public ParserRule getGroundMultiplicationRule() {
		return getGroundMultiplicationAccess().getRule();
	}

	//GroundPrimary ArithmeticTerm:
	//	term=GroundArithmeticLiteral |
	//	/ *(minus='-')?* / '(' term=Addition ')'
	public GroundPrimaryElements getGroundPrimaryAccess() {
		return pGroundPrimary;
	}
	
	public ParserRule getGroundPrimaryRule() {
		return getGroundPrimaryAccess().getRule();
	}

	//GroundArithmeticLiteral:
	//	identifier=LID | value=NUMERIC_CONSTANT;
	public GroundArithmeticLiteralElements getGroundArithmeticLiteralAccess() {
		return pGroundArithmeticLiteral;
	}
	
	public ParserRule getGroundArithmeticLiteralRule() {
		return getGroundArithmeticLiteralAccess().getRule();
	}

	//FunctionalTerm:
	//	LID '(' Terms ')';
	public FunctionalTermElements getFunctionalTermAccess() {
		return pFunctionalTerm;
	}
	
	public ParserRule getFunctionalTermRule() {
		return getFunctionalTermAccess().getRule();
	}

	//GroundFunctionalTerm:
	//	LID '(' GroundTerms ')';
	public GroundFunctionalTermElements getGroundFunctionalTermAccess() {
		return pGroundFunctionalTerm;
	}
	
	public ParserRule getGroundFunctionalTermRule() {
		return getGroundFunctionalTermAccess().getRule();
	}

	//BasicTerms:
	//	car=BasicTerm (',' cdr+=BasicTerm)*;
	public BasicTermsElements getBasicTermsAccess() {
		return pBasicTerms;
	}
	
	public ParserRule getBasicTermsRule() {
		return getBasicTermsAccess().getRule();
	}

	//GroundTerms:
	//	car=GroundTerm (',' cdr+=GroundTerm)*;
	public GroundTermsElements getGroundTermsAccess() {
		return pGroundTerms;
	}
	
	public ParserRule getGroundTermsRule() {
		return getGroundTermsAccess().getRule();
	}

	//GroundTerm:
	//	GroundArithmeticTerm | GroundFunctionalTerm;
	public GroundTermElements getGroundTermAccess() {
		return pGroundTerm;
	}
	
	public ParserRule getGroundTermRule() {
		return getGroundTermAccess().getRule();
	}

	//// 1.6 Quantified Terms, 1.14.1 Terms
	//QuantifiedTerm:
	//	UniversalQuantifiedTerm | ExistentialQuantifiedTerm;
	public QuantifiedTermElements getQuantifiedTermAccess() {
		return pQuantifiedTerm;
	}
	
	public ParserRule getQuantifiedTermRule() {
		return getQuantifiedTermAccess().getRule();
	}

	//// Vu: forbid `predicateName(quantifier typeName VarName)
	//UniversalQuantifiedTerm:
	//	'every' name=TypeId;
	public UniversalQuantifiedTermElements getUniversalQuantifiedTermAccess() {
		return pUniversalQuantifiedTerm;
	}
	
	public ParserRule getUniversalQuantifiedTermRule() {
		return getUniversalQuantifiedTermAccess().getRule();
	}

	//ExistentialQuantifiedTerm:
	//	'some' name=TypeId;
	public ExistentialQuantifiedTermElements getExistentialQuantifiedTermAccess() {
		return pExistentialQuantifiedTerm;
	}
	
	public ParserRule getExistentialQuantifiedTermRule() {
		return getExistentialQuantifiedTermAccess().getRule();
	}

	////Quantifier:
	////	mrb removed for explicit scope disambiguation in QuantifiedTerm rule above
	////	'every' | 'some';
	//// 1.7 Terms, 1.14.1 Terms
	//Term:
	//	BasicTerm | QuantifiedTerm;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//Terms:
	//	car=Term (',' cdr+=Term)*;
	public TermsElements getTermsAccess() {
		return pTerms;
	}
	
	public ParserRule getTermsRule() {
		return getTermsAccess().getRule();
	}

	//// 1.14.2, 1.3 Constant Declaration
	//ConstantDeclaration:
	//	'const' name=LID
	//	'='
	//	// (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
	//	cv=GroundArithmeticTerm
	//	'.';
	public ConstantDeclarationElements getConstantDeclarationAccess() {
		return pConstantDeclaration;
	}
	
	public ParserRule getConstantDeclarationRule() {
		return getConstantDeclarationAccess().getRule();
	}

	//// 1.5 Type Declarations, 1.14.3 Type Declarations
	//// mrb added type ID so we can use it in scoping rules
	//TypeId:
	//	name=LID;
	public TypeIdElements getTypeIdAccess() {
		return pTypeId;
	}
	
	public ParserRule getTypeIdRule() {
		return getTypeIdAccess().getRule();
	}

	//TypeDeclaration:
	//	'type' name=TypeId '=' exp=SetExpression '.';
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//Limit:
	//	cv=GroundArithmeticTerm;
	public LimitElements getLimitAccess() {
		return pLimit;
	}
	
	public ParserRule getLimitRule() {
		return getLimitAccess().getRule();
	}

	//// Vu: forbid empty type
	//Set:
	//	lhs='{' terms=GroundTerms '}';
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}

	//Range:
	//	'{' lhs=Limit '.' '.' rhs=Limit '}';
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//SetExpression:
	//	SetAddition // | SetMultiplication
	//;
	public SetExpressionElements getSetExpressionAccess() {
		return pSetExpression;
	}
	
	public ParserRule getSetExpressionRule() {
		return getSetExpressionAccess().getRule();
	}

	//SetConstruct:
	//	lhs=BasicTerm 'where' rhs=TVars;
	public SetConstructElements getSetConstructAccess() {
		return pSetConstruct;
	}
	
	public ParserRule getSetConstructRule() {
		return getSetConstructAccess().getRule();
	}

	//TVars:
	//	car=TVar (',' cdr+=TVar)*;
	public TVarsElements getTVarsAccess() {
		return pTVars;
	}
	
	public ParserRule getTVarsRule() {
		return getTVarsAccess().getRule();
	}

	//TVar:
	//	var=Variable 'in' id=TypeId;
	public TVarElements getTVarAccess() {
		return pTVar;
	}
	
	public ParserRule getTVarRule() {
		return getTVarAccess().getRule();
	}

	//SetAddition SetExpression:
	//	SetMultiplication ({SetAddition.left=current} '+' right=SetMultiplication)*
	public SetAdditionElements getSetAdditionAccess() {
		return pSetAddition;
	}
	
	public ParserRule getSetAdditionRule() {
		return getSetAdditionAccess().getRule();
	}

	//SetMultiplication SetExpression:
	//	SetPrimary ({SetMultiplication.left=current} ('*' | '\\') right=SetPrimary)*
	public SetMultiplicationElements getSetMultiplicationAccess() {
		return pSetMultiplication;
	}
	
	public ParserRule getSetMultiplicationRule() {
		return getSetMultiplicationAccess().getRule();
	}

	//SetPrimary SetExpression:
	//	SetLiteral | '(' SetAddition ')'
	public SetPrimaryElements getSetPrimaryAccess() {
		return pSetPrimary;
	}
	
	public ParserRule getSetPrimaryRule() {
		return getSetPrimaryAccess().getRule();
	}

	//SetLiteral SetExpression:
	//	Set | Range | SetConstruct | LID
	public SetLiteralElements getSetLiteralAccess() {
		return pSetLiteral;
	}
	
	public ParserRule getSetLiteralRule() {
		return getSetLiteralAccess().getRule();
	}

	//// 1.8 Atoms, 1.14.4 Atoms
	//Atom:
	//	PredicateAtom | BuiltInAtom;
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//PredicateAtom:
	//	fid=LID ('(' terms=Terms ')')?;
	public PredicateAtomElements getPredicateAtomAccess() {
		return pPredicateAtom;
	}
	
	public ParserRule getPredicateAtomRule() {
		return getPredicateAtomAccess().getRule();
	}

	//BasicPredicateAtom:
	//	fid=LID ('(' terms=BasicTerms ')')?;
	public BasicPredicateAtomElements getBasicPredicateAtomAccess() {
		return pBasicPredicateAtom;
	}
	
	public ParserRule getBasicPredicateAtomRule() {
		return getBasicPredicateAtomAccess().getRule();
	}

	//BuiltInAtom:
	//	lhs=BasicTerm op=AtomOp rhs=BasicTerm;
	public BuiltInAtomElements getBuiltInAtomAccess() {
		return pBuiltInAtom;
	}
	
	public ParserRule getBuiltInAtomRule() {
		return getBuiltInAtomAccess().getRule();
	}

	//BasicAtom:
	//	BasicPredicateAtom | BuiltInAtom;
	public BasicAtomElements getBasicAtomAccess() {
		return pBasicAtom;
	}
	
	public ParserRule getBasicAtomRule() {
		return getBasicAtomAccess().getRule();
	}

	//AtomOp:
	//	'>' | '<' | '>=' | '<=' | '=' | '!=';
	public AtomOpElements getAtomOpAccess() {
		return pAtomOp;
	}
	
	public ParserRule getAtomOpRule() {
		return getAtomOpAccess().getRule();
	}

	//// note <> not used in 1.14.4
	//// Sentences: 1.9. grammar section 1.14.5
	//Sentence:
	//	OrSentence // | AndSentence | NotSentence
	//;
	public SentenceElements getSentenceAccess() {
		return pSentence;
	}
	
	public ParserRule getSentenceRule() {
		return getSentenceAccess().getRule();
	}

	//// our left-factored version of the left-recursive grammar from specification
	//OrSentence SentenceExpr:
	//	AndSentence ({OrSentence.left=current} 'or' right=AndSentence)*
	public OrSentenceElements getOrSentenceAccess() {
		return pOrSentence;
	}
	
	public ParserRule getOrSentenceRule() {
		return getOrSentenceAccess().getRule();
	}

	//AndSentence SentenceExpr:
	//	PrimarySentence ({AndSentence.left=current} ('and' | ',') right=PrimarySentence)*
	public AndSentenceElements getAndSentenceAccess() {
		return pAndSentence;
	}
	
	public ParserRule getAndSentenceRule() {
		return getAndSentenceAccess().getRule();
	}

	//PrimarySentence SentenceExpr:
	//	SentenceLiteral |
	//	'(' OrSentence ')'
	public PrimarySentenceElements getPrimarySentenceAccess() {
		return pPrimarySentence;
	}
	
	public ParserRule getPrimarySentenceRule() {
		return getPrimarySentenceAccess().getRule();
	}

	//SentenceLiteral:
	//	Atom |
	//	'not' BasicAtom;
	public SentenceLiteralElements getSentenceLiteralAccess() {
		return pSentenceLiteral;
	}
	
	public ParserRule getSentenceLiteralRule() {
		return getSentenceLiteralAccess().getRule();
	}

	//// Predicate Sentences 
	//pSentence:
	//	pOrSentence;
	public PSentenceElements getPSentenceAccess() {
		return pPSentence;
	}
	
	public ParserRule getPSentenceRule() {
		return getPSentenceAccess().getRule();
	}

	//// our left-factored version of the left-recursive grammar from specification
	//pOrSentence SentenceExpr:
	//	pAndSentence ({pOrSentence.left=current} 'or' right=pAndSentence)*
	public POrSentenceElements getPOrSentenceAccess() {
		return pPOrSentence;
	}
	
	public ParserRule getPOrSentenceRule() {
		return getPOrSentenceAccess().getRule();
	}

	//pAndSentence SentenceExpr:
	//	pPrimarySentence ({pAndSentence.left=current} 'and' right=pPrimarySentence)*
	public PAndSentenceElements getPAndSentenceAccess() {
		return pPAndSentence;
	}
	
	public ParserRule getPAndSentenceRule() {
		return getPAndSentenceAccess().getRule();
	}

	//pPrimarySentence SentenceExpr:
	//	pSentenceLiteral |
	//	'(' pOrSentence ')'
	public PPrimarySentenceElements getPPrimarySentenceAccess() {
		return pPPrimarySentence;
	}
	
	public ParserRule getPPrimarySentenceRule() {
		return getPPrimarySentenceAccess().getRule();
	}

	//pSentenceLiteral:
	//	PredicateAtom |
	//	'not' BasicPredicateAtom;
	public PSentenceLiteralElements getPSentenceLiteralAccess() {
		return pPSentenceLiteral;
	}
	
	public ParserRule getPSentenceLiteralRule() {
		return getPSentenceLiteralAccess().getRule();
	}

	//// 1.10 Maybe Literals, 1.14.5 Maybe Literals
	//MaybeLiteral:
	//	'maybe' BasicPredicateAtom;
	public MaybeLiteralElements getMaybeLiteralAccess() {
		return pMaybeLiteral;
	}
	
	public ParserRule getMaybeLiteralRule() {
		return getMaybeLiteralAccess().getRule();
	}

	//// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
	//CardinalityConstraint:
	//	lhs=Bound '<=' '|' '{' atom=BasicPredicateAtom '}' '|' '<=' rhs=Bound;
	public CardinalityConstraintElements getCardinalityConstraintAccess() {
		return pCardinalityConstraint;
	}
	
	public ParserRule getCardinalityConstraintRule() {
		return getCardinalityConstraintAccess().getRule();
	}

	//Bound:
	//	av=ArithmeticTerm // | cv=NumericConstant | id=ID
	//;
	public BoundElements getBoundAccess() {
		return pBound;
	}
	
	public ParserRule getBoundRule() {
		return getBoundAccess().getRule();
	}

	//// 1.12 Rules, 1.14.8 Rules
	//Rule:
	//	head=Head (condition='if' body=Sentence)? '.';
	public RuleElements getRuleAccess() {
		return pRule;
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}

	//Head:
	//	pSentence | MaybeLiteral | CardinalityConstraint;
	public HeadElements getHeadAccess() {
		return pHead;
	}
	
	public ParserRule getHeadRule() {
		return getHeadAccess().getRule();
	}

	//// 1.13 Program, 1.14.9 Program
	//// by 1.14.9 a program consists of const_decls, type_decls, and rules
	//// these are our statements
	//Statement:
	//	Rule | TypeDeclaration | ConstantDeclaration;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
