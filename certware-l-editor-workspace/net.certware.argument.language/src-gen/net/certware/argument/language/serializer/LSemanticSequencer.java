/*
 * generated by Xtext
 */
package net.certware.argument.language.serializer;

import com.google.inject.Inject;
import java.util.Set;
import net.certware.argument.language.l.Addition;
import net.certware.argument.language.l.AndSentence;
import net.certware.argument.language.l.ArithmeticLiteral;
import net.certware.argument.language.l.ArithmeticTerm;
import net.certware.argument.language.l.BasicPredicateAtom;
import net.certware.argument.language.l.BasicTerms;
import net.certware.argument.language.l.Bound;
import net.certware.argument.language.l.BuiltInAtom;
import net.certware.argument.language.l.CardinalityConstraint;
import net.certware.argument.language.l.ConstantDeclaration;
import net.certware.argument.language.l.ExistentialQuantifiedTerm;
import net.certware.argument.language.l.GroundAddition;
import net.certware.argument.language.l.GroundArithmeticLiteral;
import net.certware.argument.language.l.GroundMultiplication;
import net.certware.argument.language.l.GroundTerms;
import net.certware.argument.language.l.LPackage;
import net.certware.argument.language.l.Limit;
import net.certware.argument.language.l.Multiplication;
import net.certware.argument.language.l.OrSentence;
import net.certware.argument.language.l.PredicateAtom;
import net.certware.argument.language.l.Program;
import net.certware.argument.language.l.Range;
import net.certware.argument.language.l.Rule;
import net.certware.argument.language.l.SetAddition;
import net.certware.argument.language.l.SetConstruct;
import net.certware.argument.language.l.SetMultiplication;
import net.certware.argument.language.l.TVar;
import net.certware.argument.language.l.TVars;
import net.certware.argument.language.l.Terms;
import net.certware.argument.language.l.TypeDeclaration;
import net.certware.argument.language.l.TypeId;
import net.certware.argument.language.l.TypedVariable;
import net.certware.argument.language.l.UniversalQuantifiedTerm;
import net.certware.argument.language.l.Variable;
import net.certware.argument.language.l.pAndSentence;
import net.certware.argument.language.l.pOrSentence;
import net.certware.argument.language.services.LGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case LPackage.AND_SENTENCE:
				sequence_AndSentence(context, (AndSentence) semanticObject); 
				return; 
			case LPackage.ARITHMETIC_LITERAL:
				sequence_ArithmeticLiteral(context, (ArithmeticLiteral) semanticObject); 
				return; 
			case LPackage.ARITHMETIC_TERM:
				if (rule == grammarAccess.getGroundArithmeticTermRule()
						|| rule == grammarAccess.getGroundAdditionRule()
						|| action == grammarAccess.getGroundAdditionAccess().getGroundAdditionLhsAction_1_0()
						|| rule == grammarAccess.getGroundMultiplicationRule()
						|| action == grammarAccess.getGroundMultiplicationAccess().getGroundMultiplicationLhsAction_1_0()
						|| rule == grammarAccess.getGroundPrimaryRule()
						|| rule == grammarAccess.getGroundTermRule()) {
					sequence_GroundPrimary(context, (ArithmeticTerm) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getBasicTermRule()
						|| rule == grammarAccess.getArithmeticTermRule()
						|| rule == grammarAccess.getAdditionRule()
						|| action == grammarAccess.getAdditionAccess().getAdditionLhsAction_1_0()
						|| rule == grammarAccess.getMultiplicationRule()
						|| action == grammarAccess.getMultiplicationAccess().getMultiplicationLhsAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getTermRule()) {
					sequence_Primary(context, (ArithmeticTerm) semanticObject); 
					return; 
				}
				else break;
			case LPackage.BASIC_PREDICATE_ATOM:
				sequence_BasicPredicateAtom(context, (BasicPredicateAtom) semanticObject); 
				return; 
			case LPackage.BASIC_TERMS:
				sequence_BasicTerms(context, (BasicTerms) semanticObject); 
				return; 
			case LPackage.BOUND:
				sequence_Bound(context, (Bound) semanticObject); 
				return; 
			case LPackage.BUILT_IN_ATOM:
				sequence_BuiltInAtom(context, (BuiltInAtom) semanticObject); 
				return; 
			case LPackage.CARDINALITY_CONSTRAINT:
				sequence_CardinalityConstraint(context, (CardinalityConstraint) semanticObject); 
				return; 
			case LPackage.CONSTANT_DECLARATION:
				sequence_ConstantDeclaration(context, (ConstantDeclaration) semanticObject); 
				return; 
			case LPackage.EXISTENTIAL_QUANTIFIED_TERM:
				sequence_ExistentialQuantifiedTerm(context, (ExistentialQuantifiedTerm) semanticObject); 
				return; 
			case LPackage.GROUND_ADDITION:
				sequence_GroundAddition(context, (GroundAddition) semanticObject); 
				return; 
			case LPackage.GROUND_ARITHMETIC_LITERAL:
				sequence_GroundArithmeticLiteral(context, (GroundArithmeticLiteral) semanticObject); 
				return; 
			case LPackage.GROUND_MULTIPLICATION:
				sequence_GroundMultiplication(context, (GroundMultiplication) semanticObject); 
				return; 
			case LPackage.GROUND_TERMS:
				sequence_GroundTerms(context, (GroundTerms) semanticObject); 
				return; 
			case LPackage.LIMIT:
				sequence_Limit(context, (Limit) semanticObject); 
				return; 
			case LPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case LPackage.OR_SENTENCE:
				sequence_OrSentence(context, (OrSentence) semanticObject); 
				return; 
			case LPackage.PREDICATE_ATOM:
				sequence_PredicateAtom(context, (PredicateAtom) semanticObject); 
				return; 
			case LPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case LPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case LPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case LPackage.SET:
				sequence_Set(context, (net.certware.argument.language.l.Set) semanticObject); 
				return; 
			case LPackage.SET_ADDITION:
				sequence_SetAddition(context, (SetAddition) semanticObject); 
				return; 
			case LPackage.SET_CONSTRUCT:
				sequence_SetConstruct(context, (SetConstruct) semanticObject); 
				return; 
			case LPackage.SET_MULTIPLICATION:
				sequence_SetMultiplication(context, (SetMultiplication) semanticObject); 
				return; 
			case LPackage.TVAR:
				sequence_TVar(context, (TVar) semanticObject); 
				return; 
			case LPackage.TVARS:
				sequence_TVars(context, (TVars) semanticObject); 
				return; 
			case LPackage.TERMS:
				sequence_Terms(context, (Terms) semanticObject); 
				return; 
			case LPackage.TYPE_DECLARATION:
				sequence_TypeDeclaration(context, (TypeDeclaration) semanticObject); 
				return; 
			case LPackage.TYPE_ID:
				sequence_TypeId(context, (TypeId) semanticObject); 
				return; 
			case LPackage.TYPED_VARIABLE:
				sequence_TypedVariable(context, (TypedVariable) semanticObject); 
				return; 
			case LPackage.UNIVERSAL_QUANTIFIED_TERM:
				sequence_UniversalQuantifiedTerm(context, (UniversalQuantifiedTerm) semanticObject); 
				return; 
			case LPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case LPackage.PAND_SENTENCE:
				sequence_pAndSentence(context, (pAndSentence) semanticObject); 
				return; 
			case LPackage.POR_SENTENCE:
				sequence_pOrSentence(context, (pOrSentence) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     BasicTerm returns Addition
	 *     ArithmeticTerm returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0 returns Addition
	 *     Term returns Addition
	 *
	 * Constraint:
	 *     (lhs=Addition_Addition_1_0 rhs=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getAdditionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getAdditionAccess().getRhsMultiplicationParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns AndSentence
	 *     OrSentence returns AndSentence
	 *     OrSentence.OrSentence_1_0 returns AndSentence
	 *     AndSentence returns AndSentence
	 *     AndSentence.AndSentence_1_0 returns AndSentence
	 *     PrimarySentence returns AndSentence
	 *
	 * Constraint:
	 *     (left=AndSentence_AndSentence_1_0 right=PrimarySentence)
	 */
	protected void sequence_AndSentence(ISerializationContext context, AndSentence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.AND_SENTENCE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.AND_SENTENCE__LEFT));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.AND_SENTENCE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.AND_SENTENCE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndSentenceAccess().getAndSentenceLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndSentenceAccess().getRightPrimarySentenceParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticLiteral returns ArithmeticLiteral
	 *
	 * Constraint:
	 *     (v=Variable | tv=TypedVariable | const=LID | value=NUMERIC_CONSTANT)
	 */
	protected void sequence_ArithmeticLiteral(ISerializationContext context, ArithmeticLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicPredicateAtom returns BasicPredicateAtom
	 *     BasicAtom returns BasicPredicateAtom
	 *     Sentence returns BasicPredicateAtom
	 *     OrSentence returns BasicPredicateAtom
	 *     OrSentence.OrSentence_1_0 returns BasicPredicateAtom
	 *     AndSentence returns BasicPredicateAtom
	 *     AndSentence.AndSentence_1_0 returns BasicPredicateAtom
	 *     PrimarySentence returns BasicPredicateAtom
	 *     SentenceLiteral returns BasicPredicateAtom
	 *     pSentence returns BasicPredicateAtom
	 *     pOrSentence returns BasicPredicateAtom
	 *     pOrSentence.pOrSentence_1_0 returns BasicPredicateAtom
	 *     pAndSentence returns BasicPredicateAtom
	 *     pAndSentence.pAndSentence_1_0 returns BasicPredicateAtom
	 *     pPrimarySentence returns BasicPredicateAtom
	 *     pSentenceLiteral returns BasicPredicateAtom
	 *     MaybeLiteral returns BasicPredicateAtom
	 *     Head returns BasicPredicateAtom
	 *
	 * Constraint:
	 *     (fid=LID terms=BasicTerms?)
	 */
	protected void sequence_BasicPredicateAtom(ISerializationContext context, BasicPredicateAtom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicTerms returns BasicTerms
	 *
	 * Constraint:
	 *     (car=BasicTerm cdr+=BasicTerm*)
	 */
	protected void sequence_BasicTerms(ISerializationContext context, BasicTerms semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Bound returns Bound
	 *
	 * Constraint:
	 *     av=ArithmeticTerm
	 */
	protected void sequence_Bound(ISerializationContext context, Bound semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.BOUND__AV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.BOUND__AV));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundAccess().getAvArithmeticTermParserRuleCall_0(), semanticObject.getAv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns BuiltInAtom
	 *     BuiltInAtom returns BuiltInAtom
	 *     BasicAtom returns BuiltInAtom
	 *     Sentence returns BuiltInAtom
	 *     OrSentence returns BuiltInAtom
	 *     OrSentence.OrSentence_1_0 returns BuiltInAtom
	 *     AndSentence returns BuiltInAtom
	 *     AndSentence.AndSentence_1_0 returns BuiltInAtom
	 *     PrimarySentence returns BuiltInAtom
	 *     SentenceLiteral returns BuiltInAtom
	 *
	 * Constraint:
	 *     (lhs=BasicTerm op=AtomOp rhs=BasicTerm)
	 */
	protected void sequence_BuiltInAtom(ISerializationContext context, BuiltInAtom semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.BUILT_IN_ATOM__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.BUILT_IN_ATOM__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.BUILT_IN_ATOM__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.BUILT_IN_ATOM__OP));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.BUILT_IN_ATOM__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.BUILT_IN_ATOM__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBuiltInAtomAccess().getLhsBasicTermParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getBuiltInAtomAccess().getOpAtomOpParserRuleCall_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getBuiltInAtomAccess().getRhsBasicTermParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CardinalityConstraint returns CardinalityConstraint
	 *     Head returns CardinalityConstraint
	 *
	 * Constraint:
	 *     (lhs=Bound atom=BasicPredicateAtom rhs=Bound)
	 */
	protected void sequence_CardinalityConstraint(ISerializationContext context, CardinalityConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.CARDINALITY_CONSTRAINT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.CARDINALITY_CONSTRAINT__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.CARDINALITY_CONSTRAINT__ATOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.CARDINALITY_CONSTRAINT__ATOM));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.CARDINALITY_CONSTRAINT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.CARDINALITY_CONSTRAINT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCardinalityConstraintAccess().getLhsBoundParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getCardinalityConstraintAccess().getAtomBasicPredicateAtomParserRuleCall_4_0(), semanticObject.getAtom());
		feeder.accept(grammarAccess.getCardinalityConstraintAccess().getRhsBoundParserRuleCall_8_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstantDeclaration returns ConstantDeclaration
	 *     Statement returns ConstantDeclaration
	 *
	 * Constraint:
	 *     (name=LID cv=GroundArithmeticTerm)
	 */
	protected void sequence_ConstantDeclaration(ISerializationContext context, ConstantDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.CONSTANT_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.CONSTANT_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.CONSTANT_DECLARATION__CV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.CONSTANT_DECLARATION__CV));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDeclarationAccess().getNameLIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstantDeclarationAccess().getCvGroundArithmeticTermParserRuleCall_3_0(), semanticObject.getCv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QuantifiedTerm returns ExistentialQuantifiedTerm
	 *     ExistentialQuantifiedTerm returns ExistentialQuantifiedTerm
	 *     Term returns ExistentialQuantifiedTerm
	 *
	 * Constraint:
	 *     name=TypeId
	 */
	protected void sequence_ExistentialQuantifiedTerm(ISerializationContext context, ExistentialQuantifiedTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.QUANTIFIED_TERM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.QUANTIFIED_TERM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistentialQuantifiedTermAccess().getNameTypeIdParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GroundArithmeticTerm returns GroundAddition
	 *     GroundAddition returns GroundAddition
	 *     GroundAddition.GroundAddition_1_0 returns GroundAddition
	 *     GroundTerm returns GroundAddition
	 *
	 * Constraint:
	 *     (lhs=GroundAddition_GroundAddition_1_0 rhs=GroundMultiplication)
	 */
	protected void sequence_GroundAddition(ISerializationContext context, GroundAddition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroundAdditionAccess().getGroundAdditionLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getGroundAdditionAccess().getRhsGroundMultiplicationParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GroundArithmeticLiteral returns GroundArithmeticLiteral
	 *
	 * Constraint:
	 *     (identifier=LID | value=NUMERIC_CONSTANT)
	 */
	protected void sequence_GroundArithmeticLiteral(ISerializationContext context, GroundArithmeticLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroundArithmeticTerm returns GroundMultiplication
	 *     GroundAddition returns GroundMultiplication
	 *     GroundAddition.GroundAddition_1_0 returns GroundMultiplication
	 *     GroundMultiplication returns GroundMultiplication
	 *     GroundMultiplication.GroundMultiplication_1_0 returns GroundMultiplication
	 *     GroundTerm returns GroundMultiplication
	 *
	 * Constraint:
	 *     (lhs=GroundMultiplication_GroundMultiplication_1_0 rhs=Primary)
	 */
	protected void sequence_GroundMultiplication(ISerializationContext context, GroundMultiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroundMultiplicationAccess().getGroundMultiplicationLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getGroundMultiplicationAccess().getRhsPrimaryParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GroundArithmeticTerm returns ArithmeticTerm
	 *     GroundAddition returns ArithmeticTerm
	 *     GroundAddition.GroundAddition_1_0 returns ArithmeticTerm
	 *     GroundMultiplication returns ArithmeticTerm
	 *     GroundMultiplication.GroundMultiplication_1_0 returns ArithmeticTerm
	 *     GroundPrimary returns ArithmeticTerm
	 *     GroundTerm returns ArithmeticTerm
	 *
	 * Constraint:
	 *     (term=GroundArithmeticLiteral | term=Addition)
	 */
	protected void sequence_GroundPrimary(ISerializationContext context, ArithmeticTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroundFunctionalTerm returns GroundTerms
	 *     GroundTerms returns GroundTerms
	 *     GroundTerm returns GroundTerms
	 *
	 * Constraint:
	 *     (car=GroundTerm cdr+=GroundTerm*)
	 */
	protected void sequence_GroundTerms(ISerializationContext context, GroundTerms semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Limit returns Limit
	 *
	 * Constraint:
	 *     cv=GroundArithmeticTerm
	 */
	protected void sequence_Limit(ISerializationContext context, Limit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.LIMIT__CV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.LIMIT__CV));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLimitAccess().getCvGroundArithmeticTermParserRuleCall_0(), semanticObject.getCv());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BasicTerm returns Multiplication
	 *     ArithmeticTerm returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0 returns Multiplication
	 *     Term returns Multiplication
	 *
	 * Constraint:
	 *     (lhs=Multiplication_Multiplication_1_0 rhs=Primary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.ARITHMETIC_TERM__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiplicationLhsAction_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRhsPrimaryParserRuleCall_1_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sentence returns OrSentence
	 *     OrSentence returns OrSentence
	 *     OrSentence.OrSentence_1_0 returns OrSentence
	 *     AndSentence returns OrSentence
	 *     AndSentence.AndSentence_1_0 returns OrSentence
	 *     PrimarySentence returns OrSentence
	 *
	 * Constraint:
	 *     (left=OrSentence_OrSentence_1_0 right=AndSentence)
	 */
	protected void sequence_OrSentence(ISerializationContext context, OrSentence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.OR_SENTENCE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.OR_SENTENCE__LEFT));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.OR_SENTENCE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.OR_SENTENCE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrSentenceAccess().getOrSentenceLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrSentenceAccess().getRightAndSentenceParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Atom returns PredicateAtom
	 *     PredicateAtom returns PredicateAtom
	 *     Sentence returns PredicateAtom
	 *     OrSentence returns PredicateAtom
	 *     OrSentence.OrSentence_1_0 returns PredicateAtom
	 *     AndSentence returns PredicateAtom
	 *     AndSentence.AndSentence_1_0 returns PredicateAtom
	 *     PrimarySentence returns PredicateAtom
	 *     SentenceLiteral returns PredicateAtom
	 *     pSentence returns PredicateAtom
	 *     pOrSentence returns PredicateAtom
	 *     pOrSentence.pOrSentence_1_0 returns PredicateAtom
	 *     pAndSentence returns PredicateAtom
	 *     pAndSentence.pAndSentence_1_0 returns PredicateAtom
	 *     pPrimarySentence returns PredicateAtom
	 *     pSentenceLiteral returns PredicateAtom
	 *     Head returns PredicateAtom
	 *
	 * Constraint:
	 *     (fid=LID terms=Terms?)
	 */
	protected void sequence_PredicateAtom(ISerializationContext context, PredicateAtom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicTerm returns ArithmeticTerm
	 *     ArithmeticTerm returns ArithmeticTerm
	 *     Addition returns ArithmeticTerm
	 *     Addition.Addition_1_0 returns ArithmeticTerm
	 *     Multiplication returns ArithmeticTerm
	 *     Multiplication.Multiplication_1_0 returns ArithmeticTerm
	 *     Primary returns ArithmeticTerm
	 *     Term returns ArithmeticTerm
	 *
	 * Constraint:
	 *     (term=ArithmeticLiteral | term=Addition)
	 */
	protected void sequence_Primary(ISerializationContext context, ArithmeticTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     statements+=Statement+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *     SetExpression returns Range
	 *     SetAddition returns Range
	 *     SetAddition.SetAddition_1_0 returns Range
	 *     SetMultiplication returns Range
	 *     SetMultiplication.SetMultiplication_1_0 returns Range
	 *     SetPrimary returns Range
	 *     SetLiteral returns Range
	 *
	 * Constraint:
	 *     (lhs=Limit rhs=Limit)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.RANGE__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.RANGE__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.RANGE__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.RANGE__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getLhsLimitParserRuleCall_1_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getRangeAccess().getRhsLimitParserRuleCall_4_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *     Statement returns Rule
	 *
	 * Constraint:
	 *     (head=Head (condition='if' body=Sentence)?)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SetExpression returns SetAddition
	 *     SetAddition returns SetAddition
	 *     SetAddition.SetAddition_1_0 returns SetAddition
	 *     SetMultiplication returns SetAddition
	 *     SetMultiplication.SetMultiplication_1_0 returns SetAddition
	 *     SetPrimary returns SetAddition
	 *
	 * Constraint:
	 *     (left=SetAddition_SetAddition_1_0 right=SetMultiplication)
	 */
	protected void sequence_SetAddition(ISerializationContext context, SetAddition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET_ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET_ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET_ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET_ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetAdditionAccess().getSetAdditionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSetAdditionAccess().getRightSetMultiplicationParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SetExpression returns SetConstruct
	 *     SetConstruct returns SetConstruct
	 *     SetAddition returns SetConstruct
	 *     SetAddition.SetAddition_1_0 returns SetConstruct
	 *     SetMultiplication returns SetConstruct
	 *     SetMultiplication.SetMultiplication_1_0 returns SetConstruct
	 *     SetPrimary returns SetConstruct
	 *     SetLiteral returns SetConstruct
	 *
	 * Constraint:
	 *     (lhs=BasicTerm rhs=TVars)
	 */
	protected void sequence_SetConstruct(ISerializationContext context, SetConstruct semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET_CONSTRUCT__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET_CONSTRUCT__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET_CONSTRUCT__RHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET_CONSTRUCT__RHS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetConstructAccess().getLhsBasicTermParserRuleCall_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getSetConstructAccess().getRhsTVarsParserRuleCall_2_0(), semanticObject.getRhs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SetExpression returns SetMultiplication
	 *     SetAddition returns SetMultiplication
	 *     SetAddition.SetAddition_1_0 returns SetMultiplication
	 *     SetMultiplication returns SetMultiplication
	 *     SetMultiplication.SetMultiplication_1_0 returns SetMultiplication
	 *     SetPrimary returns SetMultiplication
	 *
	 * Constraint:
	 *     (left=SetMultiplication_SetMultiplication_1_0 right=SetPrimary)
	 */
	protected void sequence_SetMultiplication(ISerializationContext context, SetMultiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET_MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET_MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET_MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET_MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetMultiplicationAccess().getSetMultiplicationLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSetMultiplicationAccess().getRightSetPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Set returns Set
	 *     SetExpression returns Set
	 *     SetAddition returns Set
	 *     SetAddition.SetAddition_1_0 returns Set
	 *     SetMultiplication returns Set
	 *     SetMultiplication.SetMultiplication_1_0 returns Set
	 *     SetPrimary returns Set
	 *     SetLiteral returns Set
	 *
	 * Constraint:
	 *     (lhs='{' terms=GroundTerms)
	 */
	protected void sequence_Set(ISerializationContext context, net.certware.argument.language.l.Set semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET__LHS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET__LHS));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.SET__TERMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.SET__TERMS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetAccess().getLhsLeftCurlyBracketKeyword_0_0(), semanticObject.getLhs());
		feeder.accept(grammarAccess.getSetAccess().getTermsGroundTermsParserRuleCall_1_0(), semanticObject.getTerms());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TVar returns TVar
	 *
	 * Constraint:
	 *     (var=Variable id=TypeId)
	 */
	protected void sequence_TVar(ISerializationContext context, TVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TVAR__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TVAR__VAR));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TVAR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TVAR__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTVarAccess().getVarVariableParserRuleCall_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getTVarAccess().getIdTypeIdParserRuleCall_2_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TVars returns TVars
	 *
	 * Constraint:
	 *     (car=TVar cdr+=TVar*)
	 */
	protected void sequence_TVars(ISerializationContext context, TVars semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BasicTerm returns Terms
	 *     FunctionalTerm returns Terms
	 *     Term returns Terms
	 *     Terms returns Terms
	 *
	 * Constraint:
	 *     (car=Term cdr+=Term*)
	 */
	protected void sequence_Terms(ISerializationContext context, Terms semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeDeclaration returns TypeDeclaration
	 *     Statement returns TypeDeclaration
	 *
	 * Constraint:
	 *     (name=TypeId exp=SetExpression)
	 */
	protected void sequence_TypeDeclaration(ISerializationContext context, TypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TYPE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TYPE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TYPE_DECLARATION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TYPE_DECLARATION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getNameTypeIdParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeDeclarationAccess().getExpSetExpressionParserRuleCall_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeId returns TypeId
	 *
	 * Constraint:
	 *     name=LID
	 */
	protected void sequence_TypeId(ISerializationContext context, TypeId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TYPE_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TYPE_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeIdAccess().getNameLIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BasicTerm returns TypedVariable
	 *     TypedVariable returns TypedVariable
	 *     Term returns TypedVariable
	 *
	 * Constraint:
	 *     (name=LID var=Variable)
	 */
	protected void sequence_TypedVariable(ISerializationContext context, TypedVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TYPED_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TYPED_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.TYPED_VARIABLE__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.TYPED_VARIABLE__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypedVariableAccess().getNameLIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypedVariableAccess().getVarVariableParserRuleCall_1_0(), semanticObject.getVar());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QuantifiedTerm returns UniversalQuantifiedTerm
	 *     UniversalQuantifiedTerm returns UniversalQuantifiedTerm
	 *     Term returns UniversalQuantifiedTerm
	 *
	 * Constraint:
	 *     name=TypeId
	 */
	protected void sequence_UniversalQuantifiedTerm(ISerializationContext context, UniversalQuantifiedTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.QUANTIFIED_TERM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.QUANTIFIED_TERM__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniversalQuantifiedTermAccess().getNameTypeIdParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     identifier=UID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.VARIABLE__IDENTIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.VARIABLE__IDENTIFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getIdentifierUIDTerminalRuleCall_0(), semanticObject.getIdentifier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     pSentence returns pAndSentence
	 *     pOrSentence returns pAndSentence
	 *     pOrSentence.pOrSentence_1_0 returns pAndSentence
	 *     pAndSentence returns pAndSentence
	 *     pAndSentence.pAndSentence_1_0 returns pAndSentence
	 *     pPrimarySentence returns pAndSentence
	 *     Head returns pAndSentence
	 *
	 * Constraint:
	 *     (left=pAndSentence_pAndSentence_1_0 right=pPrimarySentence)
	 */
	protected void sequence_pAndSentence(ISerializationContext context, pAndSentence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.PAND_SENTENCE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.PAND_SENTENCE__LEFT));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.PAND_SENTENCE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.PAND_SENTENCE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPAndSentenceAccess().getPAndSentenceLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPAndSentenceAccess().getRightPPrimarySentenceParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     pSentence returns pOrSentence
	 *     pOrSentence returns pOrSentence
	 *     pOrSentence.pOrSentence_1_0 returns pOrSentence
	 *     pAndSentence returns pOrSentence
	 *     pAndSentence.pAndSentence_1_0 returns pOrSentence
	 *     pPrimarySentence returns pOrSentence
	 *     Head returns pOrSentence
	 *
	 * Constraint:
	 *     (left=pOrSentence_pOrSentence_1_0 right=pAndSentence)
	 */
	protected void sequence_pOrSentence(ISerializationContext context, pOrSentence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.POR_SENTENCE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.POR_SENTENCE__LEFT));
			if (transientValues.isValueTransient(semanticObject, LPackage.Literals.POR_SENTENCE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LPackage.Literals.POR_SENTENCE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPOrSentenceAccess().getPOrSentenceLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPOrSentenceAccess().getRightPAndSentenceParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
