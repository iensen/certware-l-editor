grammar net.certware.argument.language.L with org.eclipse.xtext.common.Terminals

generate l "http://www.certware.net/argument/language/L"

// basic model is the program of section 1.13
Program:
	statements += Statement*
;
	
// identifier with first character lower
terminal LID : ('a'..'z')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
;

// identifier with first character upper
terminal UID : ('A'..'Z')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;


// 1.1 Symbols
//Symbol:
//	IntegerNumeral |
//	Identifier |
//	SpecialCharacter
//;

IntegerNumeral:
	INT // provided by Terminals and returning ECore Integer type 
;

Identifier:
	ID // provided by Terminals and returning ECore String type
;

//SpecialCharacter:
//	'>' | '=' | '>' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
//;


// 1.2 Basic Terms, 1.14.1 Terms
BasicTerm:
	NumericConstant |    // LID | INT
	Variable |           // UID
	TypedVariable |      // ID UID
	ArithmeticTerm |     // Addition | Multiplication
	FunctionalTerm       // ID ( BasicTerms )
;

NumericConstant:
	identifier = LID |
	numeral= IntegerNumeral 
;

Variable:
	identifier = UID
;

TypedVariable:
	type=Identifier var=Variable	
;

// our version of a left-factored equivalent of the recursive grammar from the spec
ArithmeticTerm:
	Addition | Multiplication
;

Addition returns ArithmeticTerm:
	Multiplication ({Addition.lhs=current} ('+'|'-') rhs=Multiplication)*
;

Multiplication returns ArithmeticTerm:
	Primary ({Multiplication.lhs=current} ('*'|'/'|'%') rhs=Primary)*
;

Primary returns ArithmeticTerm:
	ArithmeticLiteral |
	'(' Addition ')'
;

ArithmeticLiteral returns ArithmeticTerm:
//	v=Variable |			// UID
//	nc=NumericConstant |	// LID | INT
//	tv=TypedVariable |		// ID UID
//	i=Identifier			// ID
	identifier=ID | 
	value=INT 
;


FunctionalTerm:
	// ID'('terms+=BasicTerm+')'
	Identifier '(' BasicTerms ')'
;

BasicTerms:
	car=BasicTerm (',' cdr+=BasicTerm)*
;

//SubTerm:
//	BasicTerm	// technically incorrect, use adapter to inspect
//;

//GroundTerm:
//	BasicTerm	// technically incorrect, use adapter to inspect
//;


// 1.3 Constant Declaration
ConstantDeclaration:
	id=LID '=' (cv=NumericConstant | iv=IntegerNumeral | av=ArithmeticTerm ) '.'	
;

// 1.4 Set Expression
//SetExpression:
//	 '{' car=GroundTerm (',' cdr+=GroundTerm)* '}' |
//	id=ID |
//	// Term 'where' ... I don't understand this one
//	'(' lhs=SetExpression ('+' | '*' | '/' ) rhs=SetExpression ')' 
//;

// 1.5 Type Declarations, 1.14.3 Type Declarations
TypeDeclaration:
	id=Identifier '=' exp=SetExpression '.' 
;

Limit:
	id=Identifier | nc=NumericConstant | at=ArithmeticTerm		
;

Set:
	lhs='{' (terms=BasicTerms)? '}'
;

Range:
	'{' lhs=Limit '.' '.' rhs=Limit '}'
;

SetExpression:
	SetAddition |
	SetMultiplication
;	


SetConstruct:
	lhs=BasicTerm 'where' rhs=TVars
;

TVars:
	car=TVar (',' cdr+=TVar)*
;     

TVar:
	Variable 'in' Identifier
;

SetAddition returns SetExpression:
	SetMultiplication ({SetAddition.left=current} '+' right=SetMultiplication)* 	
;

SetMultiplication returns SetExpression:
	SetPrimary ({SetMultiplication.left=current} ('*'|'\\') right=SetPrimary)*
;

SetPrimary returns SetExpression:
	SetLiteral |
	'(' SetAddition ')'
;

SetLiteral:
	value=('set' |
			'range' |
			'set_constr')
;

// 1.6 Quantified Terms, 1.14.1 Terms
QuantifiedTerm:
//	quqntifier=('every' | 'some') p=Type |
//	'some' tVar=TypedVariable
	Quantifier Identifier Variable
;

Quantifier:
	'every' | 'some'
;

// 1.7 Terms, 1.14.1 Terms
Term:
	BasicTerm | 
	QuantifiedTerm 
;

// 1.8 Atoms, 1.14.4 Atoms
Atom:
	PredicateAtom |
	BuiltInAtom
;

PredicateAtom:
	// fid=ID(terms+=Term*)
	fid=Identifier( '(' terms=BasicTerms ')' )?	
;

BuiltInAtom:
	lhs=BasicTerm op=AtomOp rhs=BasicTerm 
;

AtomOp:
	'>' | '<' | '>=' | '<=' | '=' | '!=' ; // note <> not used in 1.14.4

// 1.9 Sentences, 1.14.5 Sentences
Sentence:
	OrSentence |
	AndSentence |
	NotSentence
;	

// our left-factored version of the left-recursive grammar from specification
OrSentence returns SentenceExpr:
	AndSentence ({OrSentence.left=current} 'or' right=OrSentence)*
;

AndSentence returns SentenceExpr:
	NotSentence ({AndSentence.left=current} 'and' right=AndSentence)*
;

NotSentence returns SentenceExpr:
	PrimarySentence | 
	'not' PrimarySentence
;

PrimarySentence returns SentenceExpr:
	SentenceLiteral |
	'(' OrSentence ')'
;

SentenceLiteral:
	PredicateAtom
;	 	

//Expression:
//	'('? 
//	('not' rhs=Atom) | 
//	(lhs=Atom 'and' rhs=Atom) | 
//	(lhs=Atom 'or' rhs=Atom) 
//	')'?	
//;

// 1.10 Maybe Literals, 1.14.5 Maybe Literals
MaybeLiteral:
	'maybe' Identifier'(' BasicTerms ')' 
;

// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
CardinalityConstraint:
	lhs=Bound '<=' '|' '{' id=Identifier '(' terms=BasicTerms ')' '}' '|' '<=' rhs=Bound
;

Bound:
	// av=ArithmeticTerm | iv=IntegerNumeral | cv=NumericConstant
	av = ArithmeticTerm | cv=NumericConstant | id=Identifier
;

// 1.12 Rules, 1.14.8 Rules
Rule:
	head=Head ('if' body=Sentence)? '.'
;

Head:
	Sentence |
	MaybeLiteral | 
	CardinalityConstraint
;


// 1.13 Program, 1.14.9 Program
// by 1.14.9 a program consists of const_decls, type_decls, and rules
// these are our statements
Statement:
	Rule |
	TypeDeclaration |
	ConstantDeclaration
;

// 1.15 Comments
// by default the generated editor will enable /* */ and // comments
