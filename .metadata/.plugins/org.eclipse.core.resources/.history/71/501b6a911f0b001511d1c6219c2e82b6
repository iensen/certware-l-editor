grammar net.certware.argument.language.L with org.eclipse.xtext.common.Terminals

generate l "http://www.certware.net/argument/language/L"

// basic model is the program of section 1.13
Program:
	statements += Statement*
;
	
// identifier with first character lower
terminal LID : ('a'..'z')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

// identifier with first character upper
terminal UID : ('A'..'Z')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;


// 1.1 Symbols
Symbol:
	IntegerNumeral |
	Identifier |
	SpecialCharacter
;

IntegerNumeral:
	INT // provided by Terminals and returning ECore Integer type 
;

Identifier:
	ID // provided by Terminals and returning ECore String type
;

SpecialCharacter:
	'>' | '=' | '>' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
;


// 1.2 Basic Terms
// Here parentheses are not optional
// We have omitted FunctionalTerm as a category of BasicTerm to preclude recursion complaint
// This omission likely is a problem owing to subterms; see page 3 of the specification.
BasicTerm:
	NumericConstant |
	Variable |
	TypedVariable |
	ArithmeticTerm |
	FunctionalTerm 
;

NumericConstant:
	identifier = LID |
	numeral=IntegerNumeral 
;

Variable:
	identifier = UID
;

TypedVariable:
	type=ID var=Variable	
;

//ArithmeticTerm:
//	'-' '(' ArithmeticTermOperand ')' |
//	'(' lhs=ArithmeticTermOperand op=('+'|'-'|'*'|'/'|'%') rhs=ArithmeticTermOperand')'
//;

//ArithmeticTermOperand: // does not include arithmetic term itself as operand
//	operand=IntegerNumeral | Variable | NumericConstant // | ArithmeticTerm
//;

ArithmeticTerm:
	'-' '(' rhs=T0 ')' |
	'(' lhs=T0 Infix1 rhs=T2 ')' |
	'(' lhs=T1 Infix2 rhs=T2 ')' |
	lhs=T0 Infix1 rhs=T2 |
	lhs=T1 Infix2 rhs=T2
;

Infix1:
	'+' | '-'
;

Infix2:
	'*' | '/' | '%'
;

Infix:
	Infix1 | Infix2
;

T0:
	T1 | 
	lhs=T0 Infix1 rhs=T1
;

T1:
	T2 |
	lhs=T1 Infix2 rhs=T2
;

T2:
	'(' t=T0 ')' |
	v=Variable |
	nc=NumericConstant |
	i=Identifier |
	tv=TypedVariable
;

FunctionalTerm:
	// ID'('terms+=BasicTerm+')'
	Identifier '(' BasicTerms ')'
;

BasicTerms:
	car=BasicTerm (',' cdr+=BasicTerm)*
;

SubTerm:
	BasicTerm	// technically incorrect, use adapter to inspect
;

GroundTerm:
	BasicTerm	// technically incorrect, use adapter to inspect
;


// 1.3 Constant Declaration
ConstantDeclaration:
	id=LID '=' (cv=NumericConstant | iv=IntegerNumeral | av=ArithmeticTerm ) '.'	
;

// 1.4 Set Expression
SetExpression:
	 '{' car=GroundTerm (',' cdr+=GroundTerm)* '}' |
	id=ID |
	// Term 'where' ... I don't understand this one
	'(' lhs=SetExpression ('+' | '*' | '/' ) rhs=SetExpression ')' 
;

// 1.5 Type Declarations, 1.14.1 Terms
TypeDeclaration:
	id=Identifier '=' exp=SetExpression '.' 
;

Limit:
	id=Identifier | nc=NumericConstant | at=ArithmeticTerm		
;

Set:
	'{' (terms+=BasicTerms)? '}'
;
     

// 1.6 Quantified Terms, 1.14.1 Terms
QuantifiedTerm:
//	quqntifier=('every' | 'some') p=Type |
//	'some' tVar=TypedVariable
	Quantifier Identifier Variable
;

Quantifier:
	'every' | 'some'
;

// 1.7 Terms, 1.14.1 Terms
Term:
	BasicTerm | 
	QuantifiedTerm 
;

// 1.8 Atoms
Atom:
	PredicateAtom |
	BuiltInAtom
;

PredicateAtom:
	fid=ID(terms+=Term*)	
;

BuiltInAtom:
	lhs=Term op=SpecialOp rhs=Term 
;

SpecialOp:
	'<' | '>' | '>=' | '<=' | '=' | '<>' ;

// 1.9 Sentences
Sentence:
	Atom |
	Expression
;	

Expression:
	'('? 
	('not' rhs=Atom) | 
	(lhs=Atom 'and' rhs=Atom) | 
	(lhs=Atom 'or' rhs=Atom) 
	')'?	
;

// 1.10 Maybe Literals
MaybeLiteral:
	'maybe' PredicateAtom '.'
;

// 1.11 Cardinality Constraint
CardinalityConstraint:
	lhs=Bound '<=' '|' '{' atom=PredicateAtom '}' '|' '<=' rhs=Bound '.'
;

Bound:
	av=ArithmeticTerm | iv=IntegerNumeral | cv=NumericConstant
;

// 1.12 Rules
Rule:
	head=Head ('if' body=Sentence)? '.'
;

Head:
	PredicateAtom | // should not contain quantified terms
	MaybeLiteral | 
	CardinalityConstraint
;


// 1.13 Program

Statement:
	Rule |
	CardinalityConstraint |
	MaybeLiteral |
	Sentence |
	Atom |
	Term |
	TypeDeclaration |
	SetExpression |
	ConstantDeclaration
;
