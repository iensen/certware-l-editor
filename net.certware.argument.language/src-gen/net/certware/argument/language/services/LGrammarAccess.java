/*
* generated by Xtext
*/
package net.certware.argument.language.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Program");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//// basic model is the program of section 1.13
		//Program:
		//	statements+=Statement*;
		public ParserRule getRule() { return rule; }

		//statements+=Statement*
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}

	public class BasicTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypedVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArithmeticTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionalTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// 1.1 Symbols
		////Symbol:
		////	IntegerNumeral |
		////	Identifier |
		////	SpecialCharacter
		////;
		//// IntegerNumeral:  MRB replaced with direct substitution of terminal INT
		////	INT // provided by Terminals and returning ECore Integer type 
		//// ;
		//// Identifier:  MRB replaced with direct subsitution of terminal ID
		////	ID // provided by Terminals and returning ECore String type
		////;
		////SpecialCharacter:
		////	'>' | '=' | '>' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
		////;
		//// 1.2 Basic Terms, 1.14.1 Terms
		//BasicTerm: // NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//	TypedVariable // ID UID
		//	// Addition | Multiplication
		//	| ArithmeticTerm | // ID ( BasicTerms )
		//	FunctionalTerm;
		public ParserRule getRule() { return rule; }

		//// NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//TypedVariable // ID UID
		//// Addition | Multiplication
		//| ArithmeticTerm | // ID ( BasicTerms )
		//FunctionalTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//// NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//TypedVariable
		public RuleCall getTypedVariableParserRuleCall_0() { return cTypedVariableParserRuleCall_0; }

		//ArithmeticTerm
		public RuleCall getArithmeticTermParserRuleCall_1() { return cArithmeticTermParserRuleCall_1; }

		//// ID ( BasicTerms )
		//FunctionalTerm
		public RuleCall getFunctionalTermParserRuleCall_2() { return cFunctionalTermParserRuleCall_2; }
	}

	public class NumericConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumericConstant:
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Assignment cIdentifierAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdentifierUIDTerminalRuleCall_0 = (RuleCall)cIdentifierAssignment.eContents().get(0);
		
		//Variable:
		//	identifier=UID;
		public ParserRule getRule() { return rule; }

		//identifier=UID
		public Assignment getIdentifierAssignment() { return cIdentifierAssignment; }

		//UID
		public RuleCall getIdentifierUIDTerminalRuleCall_0() { return cIdentifierUIDTerminalRuleCall_0; }
	}

	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeIDTerminalRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarVariableParserRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		//TypedVariable:
		//	type=ID var=Variable;
		public ParserRule getRule() { return rule; }

		//type=ID var=Variable
		public Group getGroup() { return cGroup; }

		//type=ID
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//ID
		public RuleCall getTypeIDTerminalRuleCall_0_0() { return cTypeIDTerminalRuleCall_0_0; }

		//var=Variable
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_1_0() { return cVarVariableParserRuleCall_1_0; }
	}

	public class ArithmeticTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticTerm");
		private final RuleCall cAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// our version of a left-factored equivalent of the recursive grammar from the spec
		//ArithmeticTerm: //| Multiplication
		//	Addition;
		public ParserRule getRule() { return rule; }

		////| Multiplication
		//Addition
		public RuleCall getAdditionParserRuleCall() { return cAdditionParserRuleCall; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Addition returns ArithmeticTerm:
		//	Multiplication ({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication ({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Addition.lhs=current}
		public Action getAdditionLhsAction_1_0() { return cAdditionLhsAction_1_0; }

		//"+" | "-"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_0() { return cPlusSignKeyword_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1() { return cHyphenMinusKeyword_1_1_1; }

		//rhs=Multiplication
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Multiplication
		public RuleCall getRhsMultiplicationParserRuleCall_1_2_0() { return cRhsMultiplicationParserRuleCall_1_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cPercentSignKeyword_1_1_2 = (Keyword)cAlternatives_1_1.eContents().get(2);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsPrimaryParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Multiplication returns ArithmeticTerm:
		//	Primary ({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*;
		public ParserRule getRule() { return rule; }

		//Primary ({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multiplication.lhs=current}
		public Action getMultiplicationLhsAction_1_0() { return cMultiplicationLhsAction_1_0; }

		//"*" | "/" | "%"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1_1() { return cSolidusKeyword_1_1_1; }

		//"%"
		public Keyword getPercentSignKeyword_1_1_2() { return cPercentSignKeyword_1_1_2; }

		//rhs=Primary
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Primary
		public RuleCall getRhsPrimaryParserRuleCall_1_2_0() { return cRhsPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArithmeticLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cAdditionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//Primary returns ArithmeticTerm:
		//	ArithmeticLiteral | "(" Addition ")";
		public ParserRule getRule() { return rule; }

		//ArithmeticLiteral | "(" Addition ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//ArithmeticLiteral
		public RuleCall getArithmeticLiteralParserRuleCall_0() { return cArithmeticLiteralParserRuleCall_0; }

		//"(" Addition ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//Addition
		public RuleCall getAdditionParserRuleCall_1_1() { return cAdditionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class ArithmeticLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIdentifierAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIdentifierIDTerminalRuleCall_0_0 = (RuleCall)cIdentifierAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//ArithmeticLiteral: //	v=Variable |			// UID
		////	nc=NumericConstant |	// INT
		////	tv=TypedVariable |		// ID UID
		////	i=ID			// ID
		//// below is minimalist version of above to be resolved at runtime
		//// ideally we recover the distinctions above for compile time resolution
		//	identifier=ID | value=INT;
		public ParserRule getRule() { return rule; }

		////	v=Variable |			// UID
		////	nc=NumericConstant |	// INT
		////	tv=TypedVariable |		// ID UID
		////	i=ID			// ID
		//// below is minimalist version of above to be resolved at runtime
		//// ideally we recover the distinctions above for compile time resolution
		//identifier=ID | value=INT
		public Alternatives getAlternatives() { return cAlternatives; }

		////	v=Variable |			// UID
		////	nc=NumericConstant |	// INT
		////	tv=TypedVariable |		// ID UID
		////	i=ID			// ID
		//// below is minimalist version of above to be resolved at runtime
		//// ideally we recover the distinctions above for compile time resolution
		//identifier=ID
		public Assignment getIdentifierAssignment_0() { return cIdentifierAssignment_0; }

		//ID
		public RuleCall getIdentifierIDTerminalRuleCall_0_0() { return cIdentifierIDTerminalRuleCall_0_0; }

		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }
	}

	public class FunctionalTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionalTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cBasicTermsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionalTerm: // ID'('terms+=BasicTerm+')'
		//	ID "(" BasicTerms ")";
		public ParserRule getRule() { return rule; }

		//// ID'('terms+=BasicTerm+')'
		//ID "(" BasicTerms ")"
		public Group getGroup() { return cGroup; }

		//// ID'('terms+=BasicTerm+')'
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//BasicTerms
		public RuleCall getBasicTermsParserRuleCall_2() { return cBasicTermsParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class BasicTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarBasicTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrBasicTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//BasicTerms:
		//	car=BasicTerm ("," cdr+=BasicTerm)*;
		public ParserRule getRule() { return rule; }

		//car=BasicTerm ("," cdr+=BasicTerm)*
		public Group getGroup() { return cGroup; }

		//car=BasicTerm
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//BasicTerm
		public RuleCall getCarBasicTermParserRuleCall_0_0() { return cCarBasicTermParserRuleCall_0_0; }

		//("," cdr+=BasicTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=BasicTerm
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//BasicTerm
		public RuleCall getCdrBasicTermParserRuleCall_1_1_0() { return cCdrBasicTermParserRuleCall_1_1_0; }
	}

	public class ConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdLIDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cCvAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCvArithmeticTermParserRuleCall_2_0 = (RuleCall)cCvAssignment_2.eContents().get(0);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////SubTerm:
		////	BasicTerm	// technically incorrect, use adapter to inspect
		////;
		////GroundTerm:
		////	BasicTerm	// technically incorrect, use adapter to inspect
		////;
		//// 1.3 Constant Declaration
		//ConstantDeclaration:
		//	id=LID "=" // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//	cv=ArithmeticTerm ".";
		public ParserRule getRule() { return rule; }

		//id=LID "=" // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//cv=ArithmeticTerm "."
		public Group getGroup() { return cGroup; }

		//id=LID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		//LID
		public RuleCall getIdLIDTerminalRuleCall_0_0() { return cIdLIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//// (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//cv=ArithmeticTerm
		public Assignment getCvAssignment_2() { return cCvAssignment_2; }

		//ArithmeticTerm
		public RuleCall getCvArithmeticTermParserRuleCall_2_0() { return cCvArithmeticTermParserRuleCall_2_0; }

		//"."
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdIDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Keyword cEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpSetExpressionParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// 1.4 Set Expression
		////SetExpression:
		////	 '{' car=GroundTerm (',' cdr+=GroundTerm)* '}' |
		////	id=ID |
		////	// Term 'where' ... I don't understand this one
		////	'(' lhs=SetExpression ('+' | '*' | '/' ) rhs=SetExpression ')' 
		////;
		//// 1.5 Type Declarations, 1.14.3 Type Declarations
		//TypeDeclaration:
		//	id=ID "=" exp=SetExpression ".";
		public ParserRule getRule() { return rule; }

		//id=ID "=" exp=SetExpression "."
		public Group getGroup() { return cGroup; }

		//id=ID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_0_0() { return cIdIDTerminalRuleCall_0_0; }

		//"="
		public Keyword getEqualsSignKeyword_1() { return cEqualsSignKeyword_1; }

		//exp=SetExpression
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }

		//SetExpression
		public RuleCall getExpSetExpressionParserRuleCall_2_0() { return cExpSetExpressionParserRuleCall_2_0; }

		//"."
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }
	}

	public class LimitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Limit");
		private final Assignment cCvAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCvArithmeticTermParserRuleCall_0 = (RuleCall)cCvAssignment.eContents().get(0);
		
		//Limit: //id=ID | 
		//// nc=NumericConstant | at=ArithmeticTerm
		//	cv=ArithmeticTerm;
		public ParserRule getRule() { return rule; }

		////id=ID | 
		//// nc=NumericConstant | at=ArithmeticTerm
		//cv=ArithmeticTerm
		public Assignment getCvAssignment() { return cCvAssignment; }

		//ArithmeticTerm
		public RuleCall getCvArithmeticTermParserRuleCall_0() { return cCvArithmeticTermParserRuleCall_0; }
	}

	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Set");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cLhsLeftCurlyBracketKeyword_0_0 = (Keyword)cLhsAssignment_0.eContents().get(0);
		private final Assignment cTermsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermsBasicTermsParserRuleCall_1_0 = (RuleCall)cTermsAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Set:
		//	lhs="{" terms=BasicTerms? "}";
		public ParserRule getRule() { return rule; }

		//lhs="{" terms=BasicTerms? "}"
		public Group getGroup() { return cGroup; }

		//lhs="{"
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//"{"
		public Keyword getLhsLeftCurlyBracketKeyword_0_0() { return cLhsLeftCurlyBracketKeyword_0_0; }

		//terms=BasicTerms?
		public Assignment getTermsAssignment_1() { return cTermsAssignment_1; }

		//BasicTerms
		public RuleCall getTermsBasicTermsParserRuleCall_1_0() { return cTermsBasicTermsParserRuleCall_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLhsLimitParserRuleCall_1_0 = (RuleCall)cLhsAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRhsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRhsLimitParserRuleCall_4_0 = (RuleCall)cRhsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Range:
		//	"{" lhs=Limit "." "." rhs=Limit "}";
		public ParserRule getRule() { return rule; }

		//"{" lhs=Limit "." "." rhs=Limit "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//lhs=Limit
		public Assignment getLhsAssignment_1() { return cLhsAssignment_1; }

		//Limit
		public RuleCall getLhsLimitParserRuleCall_1_0() { return cLhsLimitParserRuleCall_1_0; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }

		//"."
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }

		//rhs=Limit
		public Assignment getRhsAssignment_4() { return cRhsAssignment_4; }

		//Limit
		public RuleCall getRhsLimitParserRuleCall_4_0() { return cRhsLimitParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class SetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetExpression");
		private final RuleCall cSetAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SetExpression: // | SetMultiplication
		//	SetAddition;
		public ParserRule getRule() { return rule; }

		//// | SetMultiplication
		//SetAddition
		public RuleCall getSetAdditionParserRuleCall() { return cSetAdditionParserRuleCall; }
	}

	public class SetConstructElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetConstruct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBasicTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cWhereKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsTVarsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//SetConstruct:
		//	lhs=BasicTerm "where" rhs=TVars;
		public ParserRule getRule() { return rule; }

		//lhs=BasicTerm "where" rhs=TVars
		public Group getGroup() { return cGroup; }

		//lhs=BasicTerm
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//BasicTerm
		public RuleCall getLhsBasicTermParserRuleCall_0_0() { return cLhsBasicTermParserRuleCall_0_0; }

		//"where"
		public Keyword getWhereKeyword_1() { return cWhereKeyword_1; }

		//rhs=TVars
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//TVars
		public RuleCall getRhsTVarsParserRuleCall_2_0() { return cRhsTVarsParserRuleCall_2_0; }
	}

	public class TVarsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TVars");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarTVarParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrTVarParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//TVars:
		//	car=TVar ("," cdr+=TVar)*;
		public ParserRule getRule() { return rule; }

		//car=TVar ("," cdr+=TVar)*
		public Group getGroup() { return cGroup; }

		//car=TVar
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//TVar
		public RuleCall getCarTVarParserRuleCall_0_0() { return cCarTVarParserRuleCall_0_0; }

		//("," cdr+=TVar)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=TVar
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//TVar
		public RuleCall getCdrTVarParserRuleCall_1_1_0() { return cCdrTVarParserRuleCall_1_1_0; }
	}

	public class TVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//TVar:
		//	Variable "in" ID;
		public ParserRule getRule() { return rule; }

		//Variable "in" ID
		public Group getGroup() { return cGroup; }

		//Variable
		public RuleCall getVariableParserRuleCall_0() { return cVariableParserRuleCall_0; }

		//"in"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//ID
		public RuleCall getIDTerminalRuleCall_2() { return cIDTerminalRuleCall_2; }
	}

	public class SetAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSetAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSetMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SetAddition returns SetExpression:
		//	SetMultiplication ({SetAddition.left=current} "+" right=SetMultiplication)*;
		public ParserRule getRule() { return rule; }

		//SetMultiplication ({SetAddition.left=current} "+" right=SetMultiplication)*
		public Group getGroup() { return cGroup; }

		//SetMultiplication
		public RuleCall getSetMultiplicationParserRuleCall_0() { return cSetMultiplicationParserRuleCall_0; }

		//({SetAddition.left=current} "+" right=SetMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{SetAddition.left=current}
		public Action getSetAdditionLeftAction_1_0() { return cSetAdditionLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=SetMultiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SetMultiplication
		public RuleCall getRightSetMultiplicationParserRuleCall_1_2_0() { return cRightSetMultiplicationParserRuleCall_1_2_0; }
	}

	public class SetMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSetMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cReverseSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSetPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SetMultiplication returns SetExpression:
		//	SetPrimary ({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*;
		public ParserRule getRule() { return rule; }

		//SetPrimary ({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*
		public Group getGroup() { return cGroup; }

		//SetPrimary
		public RuleCall getSetPrimaryParserRuleCall_0() { return cSetPrimaryParserRuleCall_0; }

		//({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*
		public Group getGroup_1() { return cGroup_1; }

		//{SetMultiplication.left=current}
		public Action getSetMultiplicationLeftAction_1_0() { return cSetMultiplicationLeftAction_1_0; }

		//"*" | "\\"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//"\\"
		public Keyword getReverseSolidusKeyword_1_1_1() { return cReverseSolidusKeyword_1_1_1; }

		//right=SetPrimary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SetPrimary
		public RuleCall getRightSetPrimaryParserRuleCall_1_2_0() { return cRightSetPrimaryParserRuleCall_1_2_0; }
	}

	public class SetPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSetAdditionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//SetPrimary returns SetExpression:
		//	SetLiteral | "(" SetAddition ")";
		public ParserRule getRule() { return rule; }

		//SetLiteral | "(" SetAddition ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SetLiteral
		public RuleCall getSetLiteralParserRuleCall_0() { return cSetLiteralParserRuleCall_0; }

		//"(" SetAddition ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//SetAddition
		public RuleCall getSetAdditionParserRuleCall_1_1() { return cSetAdditionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class SetLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cValueAlternatives_0 = (Alternatives)cValueAssignment.eContents().get(0);
		private final Keyword cValueSetKeyword_0_0 = (Keyword)cValueAlternatives_0.eContents().get(0);
		private final Keyword cValueRangeKeyword_0_1 = (Keyword)cValueAlternatives_0.eContents().get(1);
		private final Keyword cValueSet_constrKeyword_0_2 = (Keyword)cValueAlternatives_0.eContents().get(2);
		
		//SetLiteral:
		//	value=("set" | "range" | "set_constr");
		public ParserRule getRule() { return rule; }

		//value=("set" | "range" | "set_constr")
		public Assignment getValueAssignment() { return cValueAssignment; }

		//"set" | "range" | "set_constr"
		public Alternatives getValueAlternatives_0() { return cValueAlternatives_0; }

		//"set"
		public Keyword getValueSetKeyword_0_0() { return cValueSetKeyword_0_0; }

		//"range"
		public Keyword getValueRangeKeyword_0_1() { return cValueRangeKeyword_0_1; }

		//"set_constr"
		public Keyword getValueSet_constrKeyword_0_2() { return cValueSet_constrKeyword_0_2; }
	}

	public class QuantifiedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantifiedTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQuantifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// 1.6 Quantified Terms, 1.14.1 Terms
		//QuantifiedTerm:
		//	Quantifier ID Variable;
		public ParserRule getRule() { return rule; }

		//Quantifier ID Variable
		public Group getGroup() { return cGroup; }

		//Quantifier
		public RuleCall getQuantifierParserRuleCall_0() { return cQuantifierParserRuleCall_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }

		//Variable
		public RuleCall getVariableParserRuleCall_2() { return cVariableParserRuleCall_2; }
	}

	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEveryKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSomeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Quantifier:
		//	"every" | "some";
		public ParserRule getRule() { return rule; }

		//"every" | "some"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"every"
		public Keyword getEveryKeyword_0() { return cEveryKeyword_0; }

		//"some"
		public Keyword getSomeKeyword_1() { return cSomeKeyword_1; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifiedTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// 1.7 Terms, 1.14.1 Terms
		//Term:
		//	BasicTerm | QuantifiedTerm;
		public ParserRule getRule() { return rule; }

		//BasicTerm | QuantifiedTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicTerm
		public RuleCall getBasicTermParserRuleCall_0() { return cBasicTermParserRuleCall_0; }

		//QuantifiedTerm
		public RuleCall getQuantifiedTermParserRuleCall_1() { return cQuantifiedTermParserRuleCall_1; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredicateAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBuiltInAtomParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// 1.8 Atoms, 1.14.4 Atoms
		//Atom:
		//	PredicateAtom | BuiltInAtom;
		public ParserRule getRule() { return rule; }

		//PredicateAtom | BuiltInAtom
		public Alternatives getAlternatives() { return cAlternatives; }

		//PredicateAtom
		public RuleCall getPredicateAtomParserRuleCall_0() { return cPredicateAtomParserRuleCall_0; }

		//BuiltInAtom
		public RuleCall getBuiltInAtomParserRuleCall_1() { return cBuiltInAtomParserRuleCall_1; }
	}

	public class PredicateAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFidAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFidIDTerminalRuleCall_0_0 = (RuleCall)cFidAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsBasicTermsParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PredicateAtom: // fid=ID(terms+=Term*)
		//	fid=ID ("(" terms=BasicTerms ")")?;
		public ParserRule getRule() { return rule; }

		//// fid=ID(terms+=Term*)
		//fid=ID ("(" terms=BasicTerms ")")?
		public Group getGroup() { return cGroup; }

		//// fid=ID(terms+=Term*)
		//fid=ID
		public Assignment getFidAssignment_0() { return cFidAssignment_0; }

		//ID
		public RuleCall getFidIDTerminalRuleCall_0_0() { return cFidIDTerminalRuleCall_0_0; }

		//("(" terms=BasicTerms ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//terms=BasicTerms
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }

		//BasicTerms
		public RuleCall getTermsBasicTermsParserRuleCall_1_1_0() { return cTermsBasicTermsParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class BuiltInAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltInAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBasicTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpAtomOpParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsBasicTermParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//BuiltInAtom:
		//	lhs=BasicTerm op=AtomOp rhs=BasicTerm;
		public ParserRule getRule() { return rule; }

		//lhs=BasicTerm op=AtomOp rhs=BasicTerm
		public Group getGroup() { return cGroup; }

		//lhs=BasicTerm
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//BasicTerm
		public RuleCall getLhsBasicTermParserRuleCall_0_0() { return cLhsBasicTermParserRuleCall_0_0; }

		//op=AtomOp
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//AtomOp
		public RuleCall getOpAtomOpParserRuleCall_1_0() { return cOpAtomOpParserRuleCall_1_0; }

		//rhs=BasicTerm
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//BasicTerm
		public RuleCall getRhsBasicTermParserRuleCall_2_0() { return cRhsBasicTermParserRuleCall_2_0; }
	}

	public class AtomOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//// note <> not used in 1.14.4
		//AtomOp:
		//	">" | "<" | ">=" | "<=" | "=" | "!=";
		public ParserRule getRule() { return rule; }

		//">" | "<" | ">=" | "<=" | "=" | "!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//">"
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_2() { return cGreaterThanSignEqualsSignKeyword_2; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }
	}

	public class SentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sentence");
		private final RuleCall cOrSentenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// 1.9 Sentences, 1.14.5 Sentences
		//Sentence: // | AndSentence | NotSentence
		//	OrSentence;
		public ParserRule getRule() { return rule; }

		//// | AndSentence | NotSentence
		//OrSentence
		public RuleCall getOrSentenceParserRuleCall() { return cOrSentenceParserRuleCall; }
	}

	public class OrSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// our left-factored version of the left-recursive grammar from specification
		//OrSentence returns SentenceExpr:
		//	AndSentence ({OrSentence.left=current} "or" right=AndSentence)* // right=OrSentence
		//;
		public ParserRule getRule() { return rule; }

		//AndSentence ({OrSentence.left=current} "or" right=AndSentence)* // right=OrSentence
		public Group getGroup() { return cGroup; }

		//AndSentence
		public RuleCall getAndSentenceParserRuleCall_0() { return cAndSentenceParserRuleCall_0; }

		//({OrSentence.left=current} "or" right=AndSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrSentence.left=current}
		public Action getOrSentenceLeftAction_1_0() { return cOrSentenceLeftAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//right=AndSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndSentence
		public RuleCall getRightAndSentenceParserRuleCall_1_2_0() { return cRightAndSentenceParserRuleCall_1_2_0; }
	}

	public class AndSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNotSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndSentence returns SentenceExpr:
		//	NotSentence ({AndSentence.left=current} "and" right=NotSentence)* // right=AndSentence
		//;
		public ParserRule getRule() { return rule; }

		//NotSentence ({AndSentence.left=current} "and" right=NotSentence)* // right=AndSentence
		public Group getGroup() { return cGroup; }

		//NotSentence
		public RuleCall getNotSentenceParserRuleCall_0() { return cNotSentenceParserRuleCall_0; }

		//({AndSentence.left=current} "and" right=NotSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndSentence.left=current}
		public Action getAndSentenceLeftAction_1_0() { return cAndSentenceLeftAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//right=NotSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//NotSentence
		public RuleCall getRightNotSentenceParserRuleCall_1_2_0() { return cRightNotSentenceParserRuleCall_1_2_0; }
	}

	public class NotSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotSentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimarySentenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPrimarySentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//NotSentence returns SentenceExpr:
		//	PrimarySentence | "not" PrimarySentence;
		public ParserRule getRule() { return rule; }

		//PrimarySentence | "not" PrimarySentence
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimarySentence
		public RuleCall getPrimarySentenceParserRuleCall_0() { return cPrimarySentenceParserRuleCall_0; }

		//"not" PrimarySentence
		public Group getGroup_1() { return cGroup_1; }

		//"not"
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//PrimarySentence
		public RuleCall getPrimarySentenceParserRuleCall_1_1() { return cPrimarySentenceParserRuleCall_1_1; }
	}

	public class PrimarySentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimarySentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSentenceLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOrSentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PrimarySentence returns SentenceExpr:
		//	SentenceLiteral | "(" OrSentence ")";
		public ParserRule getRule() { return rule; }

		//SentenceLiteral | "(" OrSentence ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SentenceLiteral
		public RuleCall getSentenceLiteralParserRuleCall_0() { return cSentenceLiteralParserRuleCall_0; }

		//"(" OrSentence ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//OrSentence
		public RuleCall getOrSentenceParserRuleCall_1_1() { return cOrSentenceParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class SentenceLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SentenceLiteral");
		private final RuleCall cPredicateAtomParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SentenceLiteral:
		//	PredicateAtom;
		public ParserRule getRule() { return rule; }

		//PredicateAtom
		public RuleCall getPredicateAtomParserRuleCall() { return cPredicateAtomParserRuleCall; }
	}

	public class MaybeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MaybeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMaybeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cBasicTermsParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		////Expression:
		////	'('? 
		////	('not' rhs=Atom) | 
		////	(lhs=Atom 'and' rhs=Atom) | 
		////	(lhs=Atom 'or' rhs=Atom) 
		////	')'?	
		////;
		//// 1.10 Maybe Literals, 1.14.5 Maybe Literals
		//MaybeLiteral:
		//	"maybe" ID "(" BasicTerms ")";
		public ParserRule getRule() { return rule; }

		//"maybe" ID "(" BasicTerms ")"
		public Group getGroup() { return cGroup; }

		//"maybe"
		public Keyword getMaybeKeyword_0() { return cMaybeKeyword_0; }

		//ID
		public RuleCall getIDTerminalRuleCall_1() { return cIDTerminalRuleCall_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }

		//BasicTerms
		public RuleCall getBasicTermsParserRuleCall_3() { return cBasicTermsParserRuleCall_3; }

		//")"
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}

	public class CardinalityConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CardinalityConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBoundParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cIdAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cIdIDTerminalRuleCall_4_0 = (RuleCall)cIdAssignment_4.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTermsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTermsBasicTermsParserRuleCall_6_0 = (RuleCall)cTermsAssignment_6.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		private final Keyword cVerticalLineKeyword_9 = (Keyword)cGroup.eContents().get(9);
		private final Keyword cLessThanSignEqualsSignKeyword_10 = (Keyword)cGroup.eContents().get(10);
		private final Assignment cRhsAssignment_11 = (Assignment)cGroup.eContents().get(11);
		private final RuleCall cRhsBoundParserRuleCall_11_0 = (RuleCall)cRhsAssignment_11.eContents().get(0);
		
		//// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
		//CardinalityConstraint:
		//	lhs=Bound "<=" "|" "{" id=ID "(" terms=BasicTerms ")" "}" "|" "<=" rhs=Bound;
		public ParserRule getRule() { return rule; }

		//lhs=Bound "<=" "|" "{" id=ID "(" terms=BasicTerms ")" "}" "|" "<=" rhs=Bound
		public Group getGroup() { return cGroup; }

		//lhs=Bound
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//Bound
		public RuleCall getLhsBoundParserRuleCall_0_0() { return cLhsBoundParserRuleCall_0_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }

		//"|"
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//id=ID
		public Assignment getIdAssignment_4() { return cIdAssignment_4; }

		//ID
		public RuleCall getIdIDTerminalRuleCall_4_0() { return cIdIDTerminalRuleCall_4_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_5() { return cLeftParenthesisKeyword_5; }

		//terms=BasicTerms
		public Assignment getTermsAssignment_6() { return cTermsAssignment_6; }

		//BasicTerms
		public RuleCall getTermsBasicTermsParserRuleCall_6_0() { return cTermsBasicTermsParserRuleCall_6_0; }

		//")"
		public Keyword getRightParenthesisKeyword_7() { return cRightParenthesisKeyword_7; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }

		//"|"
		public Keyword getVerticalLineKeyword_9() { return cVerticalLineKeyword_9; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_10() { return cLessThanSignEqualsSignKeyword_10; }

		//rhs=Bound
		public Assignment getRhsAssignment_11() { return cRhsAssignment_11; }

		//Bound
		public RuleCall getRhsBoundParserRuleCall_11_0() { return cRhsBoundParserRuleCall_11_0; }
	}

	public class BoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bound");
		private final Assignment cAvAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cAvArithmeticTermParserRuleCall_0 = (RuleCall)cAvAssignment.eContents().get(0);
		
		//Bound: // av=ArithmeticTerm | iv=INT | cv=NumericConstant
		//	av= // | cv=NumericConstant | id=ID
		//	ArithmeticTerm;
		public ParserRule getRule() { return rule; }

		//// av=ArithmeticTerm | iv=INT | cv=NumericConstant
		//av= // | cv=NumericConstant | id=ID
		//ArithmeticTerm
		public Assignment getAvAssignment() { return cAvAssignment; }

		//// | cv=NumericConstant | id=ID
		//ArithmeticTerm
		public RuleCall getAvArithmeticTermParserRuleCall_0() { return cAvArithmeticTermParserRuleCall_0; }
	}

	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadHeadParserRuleCall_0_0 = (RuleCall)cHeadAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cIfKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cBodyAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBodySentenceParserRuleCall_1_1_0 = (RuleCall)cBodyAssignment_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// 1.12 Rules, 1.14.8 Rules
		//Rule:
		//	head=Head ("if" body=Sentence)? ".";
		public ParserRule getRule() { return rule; }

		//head=Head ("if" body=Sentence)? "."
		public Group getGroup() { return cGroup; }

		//head=Head
		public Assignment getHeadAssignment_0() { return cHeadAssignment_0; }

		//Head
		public RuleCall getHeadHeadParserRuleCall_0_0() { return cHeadHeadParserRuleCall_0_0; }

		//("if" body=Sentence)?
		public Group getGroup_1() { return cGroup_1; }

		//"if"
		public Keyword getIfKeyword_1_0() { return cIfKeyword_1_0; }

		//body=Sentence
		public Assignment getBodyAssignment_1_1() { return cBodyAssignment_1_1; }

		//Sentence
		public RuleCall getBodySentenceParserRuleCall_1_1_0() { return cBodySentenceParserRuleCall_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}

	public class HeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Head");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMaybeLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCardinalityConstraintParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Head: // Sentence |
		//	MaybeLiteral | CardinalityConstraint;
		public ParserRule getRule() { return rule; }

		//// Sentence |
		//MaybeLiteral | CardinalityConstraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//// Sentence |
		//MaybeLiteral
		public RuleCall getMaybeLiteralParserRuleCall_0() { return cMaybeLiteralParserRuleCall_0; }

		//CardinalityConstraint
		public RuleCall getCardinalityConstraintParserRuleCall_1() { return cCardinalityConstraintParserRuleCall_1; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRuleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// 1.13 Program, 1.14.9 Program
		//// by 1.14.9 a program consists of const_decls, type_decls, and rules
		//// these are our statements
		//// 1.15 Comments
		//// by default the generated editor will enable / * * / and // comments
		//Statement:
		//	Rule | TypeDeclaration | ConstantDeclaration;
		public ParserRule getRule() { return rule; }

		//Rule | TypeDeclaration | ConstantDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//Rule
		public RuleCall getRuleParserRuleCall_0() { return cRuleParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_2() { return cConstantDeclarationParserRuleCall_2; }
	}
	
	
	private final ProgramElements pProgram;
	private final TerminalRule tLID;
	private final TerminalRule tUID;
	private final BasicTermElements pBasicTerm;
	private final NumericConstantElements pNumericConstant;
	private final VariableElements pVariable;
	private final TypedVariableElements pTypedVariable;
	private final ArithmeticTermElements pArithmeticTerm;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final PrimaryElements pPrimary;
	private final ArithmeticLiteralElements pArithmeticLiteral;
	private final FunctionalTermElements pFunctionalTerm;
	private final BasicTermsElements pBasicTerms;
	private final ConstantDeclarationElements pConstantDeclaration;
	private final TypeDeclarationElements pTypeDeclaration;
	private final LimitElements pLimit;
	private final SetElements pSet;
	private final RangeElements pRange;
	private final SetExpressionElements pSetExpression;
	private final SetConstructElements pSetConstruct;
	private final TVarsElements pTVars;
	private final TVarElements pTVar;
	private final SetAdditionElements pSetAddition;
	private final SetMultiplicationElements pSetMultiplication;
	private final SetPrimaryElements pSetPrimary;
	private final SetLiteralElements pSetLiteral;
	private final QuantifiedTermElements pQuantifiedTerm;
	private final QuantifierElements pQuantifier;
	private final TermElements pTerm;
	private final AtomElements pAtom;
	private final PredicateAtomElements pPredicateAtom;
	private final BuiltInAtomElements pBuiltInAtom;
	private final AtomOpElements pAtomOp;
	private final SentenceElements pSentence;
	private final OrSentenceElements pOrSentence;
	private final AndSentenceElements pAndSentence;
	private final NotSentenceElements pNotSentence;
	private final PrimarySentenceElements pPrimarySentence;
	private final SentenceLiteralElements pSentenceLiteral;
	private final MaybeLiteralElements pMaybeLiteral;
	private final CardinalityConstraintElements pCardinalityConstraint;
	private final BoundElements pBound;
	private final RuleElements pRule;
	private final HeadElements pHead;
	private final StatementElements pStatement;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.tLID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LID");
		this.tUID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UID");
		this.pBasicTerm = new BasicTermElements();
		this.pNumericConstant = new NumericConstantElements();
		this.pVariable = new VariableElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pArithmeticTerm = new ArithmeticTermElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pPrimary = new PrimaryElements();
		this.pArithmeticLiteral = new ArithmeticLiteralElements();
		this.pFunctionalTerm = new FunctionalTermElements();
		this.pBasicTerms = new BasicTermsElements();
		this.pConstantDeclaration = new ConstantDeclarationElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pLimit = new LimitElements();
		this.pSet = new SetElements();
		this.pRange = new RangeElements();
		this.pSetExpression = new SetExpressionElements();
		this.pSetConstruct = new SetConstructElements();
		this.pTVars = new TVarsElements();
		this.pTVar = new TVarElements();
		this.pSetAddition = new SetAdditionElements();
		this.pSetMultiplication = new SetMultiplicationElements();
		this.pSetPrimary = new SetPrimaryElements();
		this.pSetLiteral = new SetLiteralElements();
		this.pQuantifiedTerm = new QuantifiedTermElements();
		this.pQuantifier = new QuantifierElements();
		this.pTerm = new TermElements();
		this.pAtom = new AtomElements();
		this.pPredicateAtom = new PredicateAtomElements();
		this.pBuiltInAtom = new BuiltInAtomElements();
		this.pAtomOp = new AtomOpElements();
		this.pSentence = new SentenceElements();
		this.pOrSentence = new OrSentenceElements();
		this.pAndSentence = new AndSentenceElements();
		this.pNotSentence = new NotSentenceElements();
		this.pPrimarySentence = new PrimarySentenceElements();
		this.pSentenceLiteral = new SentenceLiteralElements();
		this.pMaybeLiteral = new MaybeLiteralElements();
		this.pCardinalityConstraint = new CardinalityConstraintElements();
		this.pBound = new BoundElements();
		this.pRule = new RuleElements();
		this.pHead = new HeadElements();
		this.pStatement = new StatementElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.certware.argument.language.L".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// basic model is the program of section 1.13
	//Program:
	//	statements+=Statement*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//// identifier with first character lower
	//terminal LID:
	//	"a".."z" ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getLIDRule() {
		return tLID;
	} 

	//// identifier with first character upper
	//terminal UID:
	//	"A".."Z" ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getUIDRule() {
		return tUID;
	} 

	//// 1.1 Symbols
	////Symbol:
	////	IntegerNumeral |
	////	Identifier |
	////	SpecialCharacter
	////;
	//// IntegerNumeral:  MRB replaced with direct substitution of terminal INT
	////	INT // provided by Terminals and returning ECore Integer type 
	//// ;
	//// Identifier:  MRB replaced with direct subsitution of terminal ID
	////	ID // provided by Terminals and returning ECore String type
	////;
	////SpecialCharacter:
	////	'>' | '=' | '>' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
	////;
	//// 1.2 Basic Terms, 1.14.1 Terms
	//BasicTerm: // NumericConstant |    // INT  covered by ArithmeticTerm
	//// Variable |           // UID  covered by ArithmeticTerm
	//	TypedVariable // ID UID
	//	// Addition | Multiplication
	//	| ArithmeticTerm | // ID ( BasicTerms )
	//	FunctionalTerm;
	public BasicTermElements getBasicTermAccess() {
		return pBasicTerm;
	}
	
	public ParserRule getBasicTermRule() {
		return getBasicTermAccess().getRule();
	}

	//NumericConstant:
	//	value=INT;
	public NumericConstantElements getNumericConstantAccess() {
		return pNumericConstant;
	}
	
	public ParserRule getNumericConstantRule() {
		return getNumericConstantAccess().getRule();
	}

	//Variable:
	//	identifier=UID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//TypedVariable:
	//	type=ID var=Variable;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}

	//// our version of a left-factored equivalent of the recursive grammar from the spec
	//ArithmeticTerm: //| Multiplication
	//	Addition;
	public ArithmeticTermElements getArithmeticTermAccess() {
		return pArithmeticTerm;
	}
	
	public ParserRule getArithmeticTermRule() {
		return getArithmeticTermAccess().getRule();
	}

	//Addition returns ArithmeticTerm:
	//	Multiplication ({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns ArithmeticTerm:
	//	Primary ({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//Primary returns ArithmeticTerm:
	//	ArithmeticLiteral | "(" Addition ")";
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//ArithmeticLiteral: //	v=Variable |			// UID
	////	nc=NumericConstant |	// INT
	////	tv=TypedVariable |		// ID UID
	////	i=ID			// ID
	//// below is minimalist version of above to be resolved at runtime
	//// ideally we recover the distinctions above for compile time resolution
	//	identifier=ID | value=INT;
	public ArithmeticLiteralElements getArithmeticLiteralAccess() {
		return pArithmeticLiteral;
	}
	
	public ParserRule getArithmeticLiteralRule() {
		return getArithmeticLiteralAccess().getRule();
	}

	//FunctionalTerm: // ID'('terms+=BasicTerm+')'
	//	ID "(" BasicTerms ")";
	public FunctionalTermElements getFunctionalTermAccess() {
		return pFunctionalTerm;
	}
	
	public ParserRule getFunctionalTermRule() {
		return getFunctionalTermAccess().getRule();
	}

	//BasicTerms:
	//	car=BasicTerm ("," cdr+=BasicTerm)*;
	public BasicTermsElements getBasicTermsAccess() {
		return pBasicTerms;
	}
	
	public ParserRule getBasicTermsRule() {
		return getBasicTermsAccess().getRule();
	}

	////SubTerm:
	////	BasicTerm	// technically incorrect, use adapter to inspect
	////;
	////GroundTerm:
	////	BasicTerm	// technically incorrect, use adapter to inspect
	////;
	//// 1.3 Constant Declaration
	//ConstantDeclaration:
	//	id=LID "=" // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
	//	cv=ArithmeticTerm ".";
	public ConstantDeclarationElements getConstantDeclarationAccess() {
		return pConstantDeclaration;
	}
	
	public ParserRule getConstantDeclarationRule() {
		return getConstantDeclarationAccess().getRule();
	}

	//// 1.4 Set Expression
	////SetExpression:
	////	 '{' car=GroundTerm (',' cdr+=GroundTerm)* '}' |
	////	id=ID |
	////	// Term 'where' ... I don't understand this one
	////	'(' lhs=SetExpression ('+' | '*' | '/' ) rhs=SetExpression ')' 
	////;
	//// 1.5 Type Declarations, 1.14.3 Type Declarations
	//TypeDeclaration:
	//	id=ID "=" exp=SetExpression ".";
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//Limit: //id=ID | 
	//// nc=NumericConstant | at=ArithmeticTerm
	//	cv=ArithmeticTerm;
	public LimitElements getLimitAccess() {
		return pLimit;
	}
	
	public ParserRule getLimitRule() {
		return getLimitAccess().getRule();
	}

	//Set:
	//	lhs="{" terms=BasicTerms? "}";
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}

	//Range:
	//	"{" lhs=Limit "." "." rhs=Limit "}";
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//SetExpression: // | SetMultiplication
	//	SetAddition;
	public SetExpressionElements getSetExpressionAccess() {
		return pSetExpression;
	}
	
	public ParserRule getSetExpressionRule() {
		return getSetExpressionAccess().getRule();
	}

	//SetConstruct:
	//	lhs=BasicTerm "where" rhs=TVars;
	public SetConstructElements getSetConstructAccess() {
		return pSetConstruct;
	}
	
	public ParserRule getSetConstructRule() {
		return getSetConstructAccess().getRule();
	}

	//TVars:
	//	car=TVar ("," cdr+=TVar)*;
	public TVarsElements getTVarsAccess() {
		return pTVars;
	}
	
	public ParserRule getTVarsRule() {
		return getTVarsAccess().getRule();
	}

	//TVar:
	//	Variable "in" ID;
	public TVarElements getTVarAccess() {
		return pTVar;
	}
	
	public ParserRule getTVarRule() {
		return getTVarAccess().getRule();
	}

	//SetAddition returns SetExpression:
	//	SetMultiplication ({SetAddition.left=current} "+" right=SetMultiplication)*;
	public SetAdditionElements getSetAdditionAccess() {
		return pSetAddition;
	}
	
	public ParserRule getSetAdditionRule() {
		return getSetAdditionAccess().getRule();
	}

	//SetMultiplication returns SetExpression:
	//	SetPrimary ({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*;
	public SetMultiplicationElements getSetMultiplicationAccess() {
		return pSetMultiplication;
	}
	
	public ParserRule getSetMultiplicationRule() {
		return getSetMultiplicationAccess().getRule();
	}

	//SetPrimary returns SetExpression:
	//	SetLiteral | "(" SetAddition ")";
	public SetPrimaryElements getSetPrimaryAccess() {
		return pSetPrimary;
	}
	
	public ParserRule getSetPrimaryRule() {
		return getSetPrimaryAccess().getRule();
	}

	//SetLiteral:
	//	value=("set" | "range" | "set_constr");
	public SetLiteralElements getSetLiteralAccess() {
		return pSetLiteral;
	}
	
	public ParserRule getSetLiteralRule() {
		return getSetLiteralAccess().getRule();
	}

	//// 1.6 Quantified Terms, 1.14.1 Terms
	//QuantifiedTerm:
	//	Quantifier ID Variable;
	public QuantifiedTermElements getQuantifiedTermAccess() {
		return pQuantifiedTerm;
	}
	
	public ParserRule getQuantifiedTermRule() {
		return getQuantifiedTermAccess().getRule();
	}

	//Quantifier:
	//	"every" | "some";
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}

	//// 1.7 Terms, 1.14.1 Terms
	//Term:
	//	BasicTerm | QuantifiedTerm;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//// 1.8 Atoms, 1.14.4 Atoms
	//Atom:
	//	PredicateAtom | BuiltInAtom;
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//PredicateAtom: // fid=ID(terms+=Term*)
	//	fid=ID ("(" terms=BasicTerms ")")?;
	public PredicateAtomElements getPredicateAtomAccess() {
		return pPredicateAtom;
	}
	
	public ParserRule getPredicateAtomRule() {
		return getPredicateAtomAccess().getRule();
	}

	//BuiltInAtom:
	//	lhs=BasicTerm op=AtomOp rhs=BasicTerm;
	public BuiltInAtomElements getBuiltInAtomAccess() {
		return pBuiltInAtom;
	}
	
	public ParserRule getBuiltInAtomRule() {
		return getBuiltInAtomAccess().getRule();
	}

	//// note <> not used in 1.14.4
	//AtomOp:
	//	">" | "<" | ">=" | "<=" | "=" | "!=";
	public AtomOpElements getAtomOpAccess() {
		return pAtomOp;
	}
	
	public ParserRule getAtomOpRule() {
		return getAtomOpAccess().getRule();
	}

	//// 1.9 Sentences, 1.14.5 Sentences
	//Sentence: // | AndSentence | NotSentence
	//	OrSentence;
	public SentenceElements getSentenceAccess() {
		return pSentence;
	}
	
	public ParserRule getSentenceRule() {
		return getSentenceAccess().getRule();
	}

	//// our left-factored version of the left-recursive grammar from specification
	//OrSentence returns SentenceExpr:
	//	AndSentence ({OrSentence.left=current} "or" right=AndSentence)* // right=OrSentence
	//;
	public OrSentenceElements getOrSentenceAccess() {
		return pOrSentence;
	}
	
	public ParserRule getOrSentenceRule() {
		return getOrSentenceAccess().getRule();
	}

	//AndSentence returns SentenceExpr:
	//	NotSentence ({AndSentence.left=current} "and" right=NotSentence)* // right=AndSentence
	//;
	public AndSentenceElements getAndSentenceAccess() {
		return pAndSentence;
	}
	
	public ParserRule getAndSentenceRule() {
		return getAndSentenceAccess().getRule();
	}

	//NotSentence returns SentenceExpr:
	//	PrimarySentence | "not" PrimarySentence;
	public NotSentenceElements getNotSentenceAccess() {
		return pNotSentence;
	}
	
	public ParserRule getNotSentenceRule() {
		return getNotSentenceAccess().getRule();
	}

	//PrimarySentence returns SentenceExpr:
	//	SentenceLiteral | "(" OrSentence ")";
	public PrimarySentenceElements getPrimarySentenceAccess() {
		return pPrimarySentence;
	}
	
	public ParserRule getPrimarySentenceRule() {
		return getPrimarySentenceAccess().getRule();
	}

	//SentenceLiteral:
	//	PredicateAtom;
	public SentenceLiteralElements getSentenceLiteralAccess() {
		return pSentenceLiteral;
	}
	
	public ParserRule getSentenceLiteralRule() {
		return getSentenceLiteralAccess().getRule();
	}

	////Expression:
	////	'('? 
	////	('not' rhs=Atom) | 
	////	(lhs=Atom 'and' rhs=Atom) | 
	////	(lhs=Atom 'or' rhs=Atom) 
	////	')'?	
	////;
	//// 1.10 Maybe Literals, 1.14.5 Maybe Literals
	//MaybeLiteral:
	//	"maybe" ID "(" BasicTerms ")";
	public MaybeLiteralElements getMaybeLiteralAccess() {
		return pMaybeLiteral;
	}
	
	public ParserRule getMaybeLiteralRule() {
		return getMaybeLiteralAccess().getRule();
	}

	//// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
	//CardinalityConstraint:
	//	lhs=Bound "<=" "|" "{" id=ID "(" terms=BasicTerms ")" "}" "|" "<=" rhs=Bound;
	public CardinalityConstraintElements getCardinalityConstraintAccess() {
		return pCardinalityConstraint;
	}
	
	public ParserRule getCardinalityConstraintRule() {
		return getCardinalityConstraintAccess().getRule();
	}

	//Bound: // av=ArithmeticTerm | iv=INT | cv=NumericConstant
	//	av= // | cv=NumericConstant | id=ID
	//	ArithmeticTerm;
	public BoundElements getBoundAccess() {
		return pBound;
	}
	
	public ParserRule getBoundRule() {
		return getBoundAccess().getRule();
	}

	//// 1.12 Rules, 1.14.8 Rules
	//Rule:
	//	head=Head ("if" body=Sentence)? ".";
	public RuleElements getRuleAccess() {
		return pRule;
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}

	//Head: // Sentence |
	//	MaybeLiteral | CardinalityConstraint;
	public HeadElements getHeadAccess() {
		return pHead;
	}
	
	public ParserRule getHeadRule() {
		return getHeadAccess().getRule();
	}

	//// 1.13 Program, 1.14.9 Program
	//// by 1.14.9 a program consists of const_decls, type_decls, and rules
	//// these are our statements
	//// 1.15 Comments
	//// by default the generated editor will enable / * * / and // comments
	//Statement:
	//	Rule | TypeDeclaration | ConstantDeclaration;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
