/*
* generated by Xtext
*/
package net.certware.argument.language.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class LGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Program");
		private final Assignment cStatementsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cStatementsStatementParserRuleCall_0 = (RuleCall)cStatementsAssignment.eContents().get(0);
		
		//// basic model is the program of section 1.13
		//Program:
		//	statements+=Statement*;
		public ParserRule getRule() { return rule; }

		//statements+=Statement*
		public Assignment getStatementsAssignment() { return cStatementsAssignment; }

		//Statement
		public RuleCall getStatementsStatementParserRuleCall_0() { return cStatementsStatementParserRuleCall_0; }
	}

	public class BasicTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cTypedVariableParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cArithmeticTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionalTermParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// 1.1 Symbols
		////Symbol:
		////	IntegerNumeral |
		////	Identifier |
		////	SpecialCharacter
		////;
		//// IntegerNumeral:  MRB replaced with direct substitution of terminal INT
		////	INT // provided by Terminals and returning ECore Integer type 
		//// ;
		//// Identifier:  MRB replaced with direct substitution of terminal ID
		////	ID // provided by Terminals and returning ECore String type
		////;
		////SpecialCharacter:
		////	'>' | '=' | '>' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
		////;
		//// 1.2 Basic Terms, 1.14.1 Terms
		//BasicTerm: // NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//	TypedVariable // ID UID
		//	// Addition | Multiplication
		//	| ArithmeticTerm | // ID ( BasicTerms )
		//	FunctionalTerm;
		public ParserRule getRule() { return rule; }

		//// NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//TypedVariable // ID UID
		//// Addition | Multiplication
		//| ArithmeticTerm | // ID ( BasicTerms )
		//FunctionalTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//// NumericConstant |    // INT  covered by ArithmeticTerm
		//// Variable |           // UID  covered by ArithmeticTerm
		//TypedVariable
		public RuleCall getTypedVariableParserRuleCall_0() { return cTypedVariableParserRuleCall_0; }

		//ArithmeticTerm
		public RuleCall getArithmeticTermParserRuleCall_1() { return cArithmeticTermParserRuleCall_1; }

		//// ID ( BasicTerms )
		//FunctionalTerm
		public RuleCall getFunctionalTermParserRuleCall_2() { return cFunctionalTermParserRuleCall_2; }
	}

	public class NumericConstantElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NumericConstant");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//NumericConstant:
		//	value=INT;
		public ParserRule getRule() { return rule; }

		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}

	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Variable");
		private final Assignment cIdentifierAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdentifierUIDTerminalRuleCall_0 = (RuleCall)cIdentifierAssignment.eContents().get(0);
		
		//Variable:
		//	identifier=UID;
		public ParserRule getRule() { return rule; }

		//identifier=UID
		public Assignment getIdentifierAssignment() { return cIdentifierAssignment; }

		//UID
		public RuleCall getIdentifierUIDTerminalRuleCall_0() { return cIdentifierUIDTerminalRuleCall_0; }
	}

	public class TypedVariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypedVariable");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeLIDTerminalRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Assignment cVarAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVarVariableParserRuleCall_1_0 = (RuleCall)cVarAssignment_1.eContents().get(0);
		
		//TypedVariable:
		//	type=LID var=Variable;
		public ParserRule getRule() { return rule; }

		//type=LID var=Variable
		public Group getGroup() { return cGroup; }

		//type=LID
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }

		//LID
		public RuleCall getTypeLIDTerminalRuleCall_0_0() { return cTypeLIDTerminalRuleCall_0_0; }

		//var=Variable
		public Assignment getVarAssignment_1() { return cVarAssignment_1; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_1_0() { return cVarVariableParserRuleCall_1_0; }
	}

	public class ArithmeticTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticTerm");
		private final RuleCall cAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// our version of a left-factored equivalent of the recursive grammar from the spec
		//ArithmeticTerm:
		//	Addition;
		public ParserRule getRule() { return rule; }

		//Addition
		public RuleCall getAdditionParserRuleCall() { return cAdditionParserRuleCall; }
	}

	public class AdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Addition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAdditionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Addition returns ArithmeticTerm:
		//	Multiplication ({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*;
		public ParserRule getRule() { return rule; }

		//Multiplication ({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*
		public Group getGroup() { return cGroup; }

		//Multiplication
		public RuleCall getMultiplicationParserRuleCall_0() { return cMultiplicationParserRuleCall_0; }

		//({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{Addition.lhs=current}
		public Action getAdditionLhsAction_1_0() { return cAdditionLhsAction_1_0; }

		//"+" | "-"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_0() { return cPlusSignKeyword_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1() { return cHyphenMinusKeyword_1_1_1; }

		//rhs=Multiplication
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Multiplication
		public RuleCall getRhsMultiplicationParserRuleCall_1_2_0() { return cRhsMultiplicationParserRuleCall_1_2_0; }
	}

	public class MultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Multiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cMultiplicationLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cPercentSignKeyword_1_1_2 = (Keyword)cAlternatives_1_1.eContents().get(2);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsPrimaryParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//Multiplication returns ArithmeticTerm:
		//	Primary ({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*;
		public ParserRule getRule() { return rule; }

		//Primary ({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*
		public Group getGroup() { return cGroup; }

		//Primary
		public RuleCall getPrimaryParserRuleCall_0() { return cPrimaryParserRuleCall_0; }

		//({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{Multiplication.lhs=current}
		public Action getMultiplicationLhsAction_1_0() { return cMultiplicationLhsAction_1_0; }

		//"*" | "/" | "%"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1_1() { return cSolidusKeyword_1_1_1; }

		//"%"
		public Keyword getPercentSignKeyword_1_1_2() { return cPercentSignKeyword_1_1_2; }

		//rhs=Primary
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Primary
		public RuleCall getRhsPrimaryParserRuleCall_1_2_0() { return cRhsPrimaryParserRuleCall_1_2_0; }
	}

	public class PrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Primary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cMinusAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cMinusHyphenMinusKeyword_0_0_0 = (Keyword)cMinusAssignment_0_0.eContents().get(0);
		private final Assignment cTermAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTermArithmeticLiteralParserRuleCall_0_1_0 = (RuleCall)cTermAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cMinusAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cMinusHyphenMinusKeyword_1_0_0 = (Keyword)cMinusAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTermAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTermAdditionParserRuleCall_1_2_0 = (RuleCall)cTermAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//Primary returns ArithmeticTerm:
		//	minus="-"? term=ArithmeticLiteral | minus="-"? "(" term=Addition ")";
		public ParserRule getRule() { return rule; }

		//minus="-"? term=ArithmeticLiteral | minus="-"? "(" term=Addition ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//minus="-"? term=ArithmeticLiteral
		public Group getGroup_0() { return cGroup_0; }

		//minus="-"?
		public Assignment getMinusAssignment_0_0() { return cMinusAssignment_0_0; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_0_0_0() { return cMinusHyphenMinusKeyword_0_0_0; }

		//term=ArithmeticLiteral
		public Assignment getTermAssignment_0_1() { return cTermAssignment_0_1; }

		//ArithmeticLiteral
		public RuleCall getTermArithmeticLiteralParserRuleCall_0_1_0() { return cTermArithmeticLiteralParserRuleCall_0_1_0; }

		//minus="-"? "(" term=Addition ")"
		public Group getGroup_1() { return cGroup_1; }

		//minus="-"?
		public Assignment getMinusAssignment_1_0() { return cMinusAssignment_1_0; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_1_0_0() { return cMinusHyphenMinusKeyword_1_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//term=Addition
		public Assignment getTermAssignment_1_2() { return cTermAssignment_1_2; }

		//Addition
		public RuleCall getTermAdditionParserRuleCall_1_2_0() { return cTermAdditionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class ArithmeticLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ArithmeticLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cVAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cVVariableParserRuleCall_0_0 = (RuleCall)cVAssignment_0.eContents().get(0);
		private final Assignment cTvAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cTvTypedVariableParserRuleCall_1_0 = (RuleCall)cTvAssignment_1.eContents().get(0);
		private final Assignment cConstAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cConstLIDTerminalRuleCall_2_0 = (RuleCall)cConstAssignment_2.eContents().get(0);
		private final Assignment cValueAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cValueINTTerminalRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ArithmeticLiteral:
		//	v=Variable // UID
		//	//CONST
		//	| tv=TypedVariable | const=LID | value=INT;
		public ParserRule getRule() { return rule; }

		//v=Variable // UID
		////CONST
		//| tv=TypedVariable | const=LID | value=INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//v=Variable
		public Assignment getVAssignment_0() { return cVAssignment_0; }

		//Variable
		public RuleCall getVVariableParserRuleCall_0_0() { return cVVariableParserRuleCall_0_0; }

		//tv=TypedVariable
		public Assignment getTvAssignment_1() { return cTvAssignment_1; }

		//TypedVariable
		public RuleCall getTvTypedVariableParserRuleCall_1_0() { return cTvTypedVariableParserRuleCall_1_0; }

		//const=LID
		public Assignment getConstAssignment_2() { return cConstAssignment_2; }

		//LID
		public RuleCall getConstLIDTerminalRuleCall_2_0() { return cConstLIDTerminalRuleCall_2_0; }

		//value=INT
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_3_0() { return cValueINTTerminalRuleCall_3_0; }
	}

	public class GroundArithmeticTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundArithmeticTerm");
		private final RuleCall cGroundAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// ground arithmetic term from 1.2 and  1.14.1, 
		//// reuse the definition of Arithmetic Term
		//GroundArithmeticTerm:
		//	GroundAddition;
		public ParserRule getRule() { return rule; }

		//GroundAddition
		public RuleCall getGroundAdditionParserRuleCall() { return cGroundAdditionParserRuleCall; }
	}

	public class GroundAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGroundMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cGroundAdditionLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsGroundMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//GroundAddition returns ArithmeticTerm:
		//	GroundMultiplication ({GroundAddition.lhs=current} ("+" | "-") rhs=GroundMultiplication)*;
		public ParserRule getRule() { return rule; }

		//GroundMultiplication ({GroundAddition.lhs=current} ("+" | "-") rhs=GroundMultiplication)*
		public Group getGroup() { return cGroup; }

		//GroundMultiplication
		public RuleCall getGroundMultiplicationParserRuleCall_0() { return cGroundMultiplicationParserRuleCall_0; }

		//({GroundAddition.lhs=current} ("+" | "-") rhs=GroundMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{GroundAddition.lhs=current}
		public Action getGroundAdditionLhsAction_1_0() { return cGroundAdditionLhsAction_1_0; }

		//"+" | "-"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"+"
		public Keyword getPlusSignKeyword_1_1_0() { return cPlusSignKeyword_1_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_1_1() { return cHyphenMinusKeyword_1_1_1; }

		//rhs=GroundMultiplication
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//GroundMultiplication
		public RuleCall getRhsGroundMultiplicationParserRuleCall_1_2_0() { return cRhsGroundMultiplicationParserRuleCall_1_2_0; }
	}

	public class GroundMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cGroundPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cGroundMultiplicationLhsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Keyword cPercentSignKeyword_1_1_2 = (Keyword)cAlternatives_1_1.eContents().get(2);
		private final Assignment cRhsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRhsPrimaryParserRuleCall_1_2_0 = (RuleCall)cRhsAssignment_1_2.eContents().get(0);
		
		//GroundMultiplication returns ArithmeticTerm:
		//	GroundPrimary ({GroundMultiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*;
		public ParserRule getRule() { return rule; }

		//GroundPrimary ({GroundMultiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*
		public Group getGroup() { return cGroup; }

		//GroundPrimary
		public RuleCall getGroundPrimaryParserRuleCall_0() { return cGroundPrimaryParserRuleCall_0; }

		//({GroundMultiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*
		public Group getGroup_1() { return cGroup_1; }

		//{GroundMultiplication.lhs=current}
		public Action getGroundMultiplicationLhsAction_1_0() { return cGroundMultiplicationLhsAction_1_0; }

		//"*" | "/" | "%"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_1_1() { return cSolidusKeyword_1_1_1; }

		//"%"
		public Keyword getPercentSignKeyword_1_1_2() { return cPercentSignKeyword_1_1_2; }

		//rhs=Primary
		public Assignment getRhsAssignment_1_2() { return cRhsAssignment_1_2; }

		//Primary
		public RuleCall getRhsPrimaryParserRuleCall_1_2_0() { return cRhsPrimaryParserRuleCall_1_2_0; }
	}

	public class GroundPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cMinusAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final Keyword cMinusHyphenMinusKeyword_0_0_0 = (Keyword)cMinusAssignment_0_0.eContents().get(0);
		private final Assignment cTermAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cTermGroundArithmeticLiteralParserRuleCall_0_1_0 = (RuleCall)cTermAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cMinusAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cMinusHyphenMinusKeyword_1_0_0 = (Keyword)cMinusAssignment_1_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTermAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTermAdditionParserRuleCall_1_2_0 = (RuleCall)cTermAssignment_1_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		
		//GroundPrimary returns ArithmeticTerm:
		//	minus="-"? term=GroundArithmeticLiteral | minus="-"? "(" term=Addition ")";
		public ParserRule getRule() { return rule; }

		//minus="-"? term=GroundArithmeticLiteral | minus="-"? "(" term=Addition ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//minus="-"? term=GroundArithmeticLiteral
		public Group getGroup_0() { return cGroup_0; }

		//minus="-"?
		public Assignment getMinusAssignment_0_0() { return cMinusAssignment_0_0; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_0_0_0() { return cMinusHyphenMinusKeyword_0_0_0; }

		//term=GroundArithmeticLiteral
		public Assignment getTermAssignment_0_1() { return cTermAssignment_0_1; }

		//GroundArithmeticLiteral
		public RuleCall getTermGroundArithmeticLiteralParserRuleCall_0_1_0() { return cTermGroundArithmeticLiteralParserRuleCall_0_1_0; }

		//minus="-"? "(" term=Addition ")"
		public Group getGroup_1() { return cGroup_1; }

		//minus="-"?
		public Assignment getMinusAssignment_1_0() { return cMinusAssignment_1_0; }

		//"-"
		public Keyword getMinusHyphenMinusKeyword_1_0_0() { return cMinusHyphenMinusKeyword_1_0_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_1() { return cLeftParenthesisKeyword_1_1; }

		//term=Addition
		public Assignment getTermAssignment_1_2() { return cTermAssignment_1_2; }

		//Addition
		public RuleCall getTermAdditionParserRuleCall_1_2_0() { return cTermAdditionParserRuleCall_1_2_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_3() { return cRightParenthesisKeyword_1_3; }
	}

	public class GroundArithmeticLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundArithmeticLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cIdentifierAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cIdentifierLIDTerminalRuleCall_0_0 = (RuleCall)cIdentifierAssignment_0.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		
		//GroundArithmeticLiteral:
		//	identifier=LID | value=INT;
		public ParserRule getRule() { return rule; }

		//identifier=LID | value=INT
		public Alternatives getAlternatives() { return cAlternatives; }

		//identifier=LID
		public Assignment getIdentifierAssignment_0() { return cIdentifierAssignment_0; }

		//LID
		public RuleCall getIdentifierLIDTerminalRuleCall_0_0() { return cIdentifierLIDTerminalRuleCall_0_0; }

		//value=INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }

		//INT
		public RuleCall getValueINTTerminalRuleCall_1_0() { return cValueINTTerminalRuleCall_1_0; }
	}

	public class FunctionalTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "FunctionalTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cTermsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//FunctionalTerm: // ID'('terms+=BasicTerm+')'
		//	LID "(" Terms ")";
		public ParserRule getRule() { return rule; }

		//// ID'('terms+=BasicTerm+')'
		//LID "(" Terms ")"
		public Group getGroup() { return cGroup; }

		//// ID'('terms+=BasicTerm+')'
		//LID
		public RuleCall getLIDTerminalRuleCall_0() { return cLIDTerminalRuleCall_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//Terms
		public RuleCall getTermsParserRuleCall_2() { return cTermsParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class GroundFunctionalTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundFunctionalTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cGroundTermsParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//GroundFunctionalTerm: // ID'('terms+=BasicTerm+')'
		//	LID "(" GroundTerms ")";
		public ParserRule getRule() { return rule; }

		//// ID'('terms+=BasicTerm+')'
		//LID "(" GroundTerms ")"
		public Group getGroup() { return cGroup; }

		//// ID'('terms+=BasicTerm+')'
		//LID
		public RuleCall getLIDTerminalRuleCall_0() { return cLIDTerminalRuleCall_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }

		//GroundTerms
		public RuleCall getGroundTermsParserRuleCall_2() { return cGroundTermsParserRuleCall_2; }

		//")"
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}

	public class BasicTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarBasicTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrBasicTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//BasicTerms:
		//	car=BasicTerm ("," cdr+=BasicTerm)*;
		public ParserRule getRule() { return rule; }

		//car=BasicTerm ("," cdr+=BasicTerm)*
		public Group getGroup() { return cGroup; }

		//car=BasicTerm
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//BasicTerm
		public RuleCall getCarBasicTermParserRuleCall_0_0() { return cCarBasicTermParserRuleCall_0_0; }

		//("," cdr+=BasicTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=BasicTerm
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//BasicTerm
		public RuleCall getCdrBasicTermParserRuleCall_1_1_0() { return cCdrBasicTermParserRuleCall_1_1_0; }
	}

	public class GroundTermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundTerms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarGroundTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrGroundTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//GroundTerms:
		//	car=GroundTerm ("," cdr+=GroundTerm)*;
		public ParserRule getRule() { return rule; }

		//car=GroundTerm ("," cdr+=GroundTerm)*
		public Group getGroup() { return cGroup; }

		//car=GroundTerm
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//GroundTerm
		public RuleCall getCarGroundTermParserRuleCall_0_0() { return cCarGroundTermParserRuleCall_0_0; }

		//("," cdr+=GroundTerm)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=GroundTerm
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//GroundTerm
		public RuleCall getCdrGroundTermParserRuleCall_1_1_0() { return cCdrGroundTermParserRuleCall_1_1_0; }
	}

	public class GroundTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "GroundTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGroundArithmeticTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cGroundFunctionalTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//GroundTerm:
		//	GroundArithmeticTerm | GroundFunctionalTerm;
		public ParserRule getRule() { return rule; }

		//GroundArithmeticTerm | GroundFunctionalTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//GroundArithmeticTerm
		public RuleCall getGroundArithmeticTermParserRuleCall_0() { return cGroundArithmeticTermParserRuleCall_0; }

		//GroundFunctionalTerm
		public RuleCall getGroundFunctionalTermParserRuleCall_1() { return cGroundFunctionalTermParserRuleCall_1; }
	}

	public class QuantifiedTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "QuantifiedTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cQuantifierParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cLIDTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cVariableParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//// 1.6 Quantified Terms, 1.14.1 Terms
		//QuantifiedTerm:
		//	Quantifier LID Variable?;
		public ParserRule getRule() { return rule; }

		//Quantifier LID Variable?
		public Group getGroup() { return cGroup; }

		//Quantifier
		public RuleCall getQuantifierParserRuleCall_0() { return cQuantifierParserRuleCall_0; }

		//LID
		public RuleCall getLIDTerminalRuleCall_1() { return cLIDTerminalRuleCall_1; }

		//Variable?
		public RuleCall getVariableParserRuleCall_2() { return cVariableParserRuleCall_2; }
	}

	public class QuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Quantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cEveryKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cSomeKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		
		//Quantifier:
		//	"every" | "some";
		public ParserRule getRule() { return rule; }

		//"every" | "some"
		public Alternatives getAlternatives() { return cAlternatives; }

		//"every"
		public Keyword getEveryKeyword_0() { return cEveryKeyword_0; }

		//"some"
		public Keyword getSomeKeyword_1() { return cSomeKeyword_1; }
	}

	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Term");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBasicTermParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQuantifiedTermParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// 1.7 Terms, 1.14.1 Terms
		//Term:
		//	BasicTerm | QuantifiedTerm;
		public ParserRule getRule() { return rule; }

		//BasicTerm | QuantifiedTerm
		public Alternatives getAlternatives() { return cAlternatives; }

		//BasicTerm
		public RuleCall getBasicTermParserRuleCall_0() { return cBasicTermParserRuleCall_0; }

		//QuantifiedTerm
		public RuleCall getQuantifiedTermParserRuleCall_1() { return cQuantifiedTermParserRuleCall_1; }
	}

	public class TermsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Terms");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarTermParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrTermParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//Terms:
		//	car=Term ("," cdr+=Term)*;
		public ParserRule getRule() { return rule; }

		//car=Term ("," cdr+=Term)*
		public Group getGroup() { return cGroup; }

		//car=Term
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//Term
		public RuleCall getCarTermParserRuleCall_0_0() { return cCarTermParserRuleCall_0_0; }

		//("," cdr+=Term)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=Term
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//Term
		public RuleCall getCdrTermParserRuleCall_1_1_0() { return cCdrTermParserRuleCall_1_1_0; }
	}

	public class ConstantDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ConstantDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdLIDTerminalRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cCvAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cCvGroundArithmeticTermParserRuleCall_3_0 = (RuleCall)cCvAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// 1.14.2, 1.3 Constant Declaration
		//ConstantDeclaration:
		//	"const" id=LID "=" // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//	cv=GroundArithmeticTerm ".";
		public ParserRule getRule() { return rule; }

		//"const" id=LID "=" // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//cv=GroundArithmeticTerm "."
		public Group getGroup() { return cGroup; }

		//"const"
		public Keyword getConstKeyword_0() { return cConstKeyword_0; }

		//id=LID
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//LID
		public RuleCall getIdLIDTerminalRuleCall_1_0() { return cIdLIDTerminalRuleCall_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//// (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
		//cv=GroundArithmeticTerm
		public Assignment getCvAssignment_3() { return cCvAssignment_3; }

		//GroundArithmeticTerm
		public RuleCall getCvGroundArithmeticTermParserRuleCall_3_0() { return cCvGroundArithmeticTermParserRuleCall_3_0; }

		//"."
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}

	public class TypeDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TypeDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cTypeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cIdAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cIdLIDTerminalRuleCall_1_0 = (RuleCall)cIdAssignment_1.eContents().get(0);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cExpAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cExpSetExpressionParserRuleCall_3_0 = (RuleCall)cExpAssignment_3.eContents().get(0);
		private final Keyword cFullStopKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// 1.5 Type Declarations, 1.14.3 Type Declarations
		//TypeDeclaration:
		//	"type" id=LID "=" exp=SetExpression ".";
		public ParserRule getRule() { return rule; }

		//"type" id=LID "=" exp=SetExpression "."
		public Group getGroup() { return cGroup; }

		//"type"
		public Keyword getTypeKeyword_0() { return cTypeKeyword_0; }

		//id=LID
		public Assignment getIdAssignment_1() { return cIdAssignment_1; }

		//LID
		public RuleCall getIdLIDTerminalRuleCall_1_0() { return cIdLIDTerminalRuleCall_1_0; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//exp=SetExpression
		public Assignment getExpAssignment_3() { return cExpAssignment_3; }

		//SetExpression
		public RuleCall getExpSetExpressionParserRuleCall_3_0() { return cExpSetExpressionParserRuleCall_3_0; }

		//"."
		public Keyword getFullStopKeyword_4() { return cFullStopKeyword_4; }
	}

	public class LimitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Limit");
		private final Assignment cCvAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cCvGroundArithmeticTermParserRuleCall_0 = (RuleCall)cCvAssignment.eContents().get(0);
		
		//Limit: //id=ID | 
		//// nc=NumericConstant | at=ArithmeticTerm
		//	cv=GroundArithmeticTerm;
		public ParserRule getRule() { return rule; }

		////id=ID | 
		//// nc=NumericConstant | at=ArithmeticTerm
		//cv=GroundArithmeticTerm
		public Assignment getCvAssignment() { return cCvAssignment; }

		//GroundArithmeticTerm
		public RuleCall getCvGroundArithmeticTermParserRuleCall_0() { return cCvGroundArithmeticTermParserRuleCall_0; }
	}

	public class SetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Set");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cLhsLeftCurlyBracketKeyword_0_0 = (Keyword)cLhsAssignment_0.eContents().get(0);
		private final Assignment cTermsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTermsGroundTermsParserRuleCall_1_0 = (RuleCall)cTermsAssignment_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Set:
		//	lhs="{" terms=GroundTerms? "}";
		public ParserRule getRule() { return rule; }

		//lhs="{" terms=GroundTerms? "}"
		public Group getGroup() { return cGroup; }

		//lhs="{"
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//"{"
		public Keyword getLhsLeftCurlyBracketKeyword_0_0() { return cLhsLeftCurlyBracketKeyword_0_0; }

		//terms=GroundTerms?
		public Assignment getTermsAssignment_1() { return cTermsAssignment_1; }

		//GroundTerms
		public RuleCall getTermsGroundTermsParserRuleCall_1_0() { return cTermsGroundTermsParserRuleCall_1_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_2() { return cRightCurlyBracketKeyword_2; }
	}

	public class RangeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Range");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cLhsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cLhsLimitParserRuleCall_1_0 = (RuleCall)cLhsAssignment_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cRhsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cRhsLimitParserRuleCall_4_0 = (RuleCall)cRhsAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Range:
		//	"{" lhs=Limit "." "." rhs=Limit "}";
		public ParserRule getRule() { return rule; }

		//"{" lhs=Limit "." "." rhs=Limit "}"
		public Group getGroup() { return cGroup; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_0() { return cLeftCurlyBracketKeyword_0; }

		//lhs=Limit
		public Assignment getLhsAssignment_1() { return cLhsAssignment_1; }

		//Limit
		public RuleCall getLhsLimitParserRuleCall_1_0() { return cLhsLimitParserRuleCall_1_0; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }

		//"."
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }

		//rhs=Limit
		public Assignment getRhsAssignment_4() { return cRhsAssignment_4; }

		//Limit
		public RuleCall getRhsLimitParserRuleCall_4_0() { return cRhsLimitParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }
	}

	public class SetExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetExpression");
		private final RuleCall cSetAdditionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SetExpression: // | SetMultiplication
		//	SetAddition;
		public ParserRule getRule() { return rule; }

		//// | SetMultiplication
		//SetAddition
		public RuleCall getSetAdditionParserRuleCall() { return cSetAdditionParserRuleCall; }
	}

	public class SetConstructElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetConstruct");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBasicTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cWhereKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsTVarsParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//SetConstruct:
		//	lhs=BasicTerm "where" rhs=TVars;
		public ParserRule getRule() { return rule; }

		//lhs=BasicTerm "where" rhs=TVars
		public Group getGroup() { return cGroup; }

		//lhs=BasicTerm
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//BasicTerm
		public RuleCall getLhsBasicTermParserRuleCall_0_0() { return cLhsBasicTermParserRuleCall_0_0; }

		//"where"
		public Keyword getWhereKeyword_1() { return cWhereKeyword_1; }

		//rhs=TVars
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//TVars
		public RuleCall getRhsTVarsParserRuleCall_2_0() { return cRhsTVarsParserRuleCall_2_0; }
	}

	public class TVarsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TVars");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCarTVarParserRuleCall_0_0 = (RuleCall)cCarAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cCdrAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cCdrTVarParserRuleCall_1_1_0 = (RuleCall)cCdrAssignment_1_1.eContents().get(0);
		
		//TVars:
		//	car=TVar ("," cdr+=TVar)*;
		public ParserRule getRule() { return rule; }

		//car=TVar ("," cdr+=TVar)*
		public Group getGroup() { return cGroup; }

		//car=TVar
		public Assignment getCarAssignment_0() { return cCarAssignment_0; }

		//TVar
		public RuleCall getCarTVarParserRuleCall_0_0() { return cCarTVarParserRuleCall_0_0; }

		//("," cdr+=TVar)*
		public Group getGroup_1() { return cGroup_1; }

		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }

		//cdr+=TVar
		public Assignment getCdrAssignment_1_1() { return cCdrAssignment_1_1; }

		//TVar
		public RuleCall getCdrTVarParserRuleCall_1_1_0() { return cCdrTVarParserRuleCall_1_1_0; }
	}

	public class TVarElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "TVar");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cVarAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cVarVariableParserRuleCall_0_0 = (RuleCall)cVarAssignment_0.eContents().get(0);
		private final Keyword cInKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIdAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIdLIDTerminalRuleCall_2_0 = (RuleCall)cIdAssignment_2.eContents().get(0);
		
		//TVar:
		//	var=Variable "in" id=LID;
		public ParserRule getRule() { return rule; }

		//var=Variable "in" id=LID
		public Group getGroup() { return cGroup; }

		//var=Variable
		public Assignment getVarAssignment_0() { return cVarAssignment_0; }

		//Variable
		public RuleCall getVarVariableParserRuleCall_0_0() { return cVarVariableParserRuleCall_0_0; }

		//"in"
		public Keyword getInKeyword_1() { return cInKeyword_1; }

		//id=LID
		public Assignment getIdAssignment_2() { return cIdAssignment_2; }

		//LID
		public RuleCall getIdLIDTerminalRuleCall_2_0() { return cIdLIDTerminalRuleCall_2_0; }
	}

	public class SetAdditionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetAddition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetMultiplicationParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSetAdditionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSetMultiplicationParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SetAddition returns SetExpression:
		//	SetMultiplication ({SetAddition.left=current} "+" right=SetMultiplication)*;
		public ParserRule getRule() { return rule; }

		//SetMultiplication ({SetAddition.left=current} "+" right=SetMultiplication)*
		public Group getGroup() { return cGroup; }

		//SetMultiplication
		public RuleCall getSetMultiplicationParserRuleCall_0() { return cSetMultiplicationParserRuleCall_0; }

		//({SetAddition.left=current} "+" right=SetMultiplication)*
		public Group getGroup_1() { return cGroup_1; }

		//{SetAddition.left=current}
		public Action getSetAdditionLeftAction_1_0() { return cSetAdditionLeftAction_1_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_1() { return cPlusSignKeyword_1_1; }

		//right=SetMultiplication
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SetMultiplication
		public RuleCall getRightSetMultiplicationParserRuleCall_1_2_0() { return cRightSetMultiplicationParserRuleCall_1_2_0; }
	}

	public class SetMultiplicationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetMultiplication");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSetPrimaryParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cSetMultiplicationLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAsteriskKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cReverseSolidusKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSetPrimaryParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//SetMultiplication returns SetExpression:
		//	SetPrimary ({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*;
		public ParserRule getRule() { return rule; }

		//SetPrimary ({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*
		public Group getGroup() { return cGroup; }

		//SetPrimary
		public RuleCall getSetPrimaryParserRuleCall_0() { return cSetPrimaryParserRuleCall_0; }

		//({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*
		public Group getGroup_1() { return cGroup_1; }

		//{SetMultiplication.left=current}
		public Action getSetMultiplicationLeftAction_1_0() { return cSetMultiplicationLeftAction_1_0; }

		//"*" | "\\"
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"*"
		public Keyword getAsteriskKeyword_1_1_0() { return cAsteriskKeyword_1_1_0; }

		//"\\"
		public Keyword getReverseSolidusKeyword_1_1_1() { return cReverseSolidusKeyword_1_1_1; }

		//right=SetPrimary
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//SetPrimary
		public RuleCall getRightSetPrimaryParserRuleCall_1_2_0() { return cRightSetPrimaryParserRuleCall_1_2_0; }
	}

	public class SetPrimaryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetPrimary");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cSetAdditionParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//SetPrimary returns SetExpression:
		//	SetLiteral | "(" SetAddition ")";
		public ParserRule getRule() { return rule; }

		//SetLiteral | "(" SetAddition ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SetLiteral
		public RuleCall getSetLiteralParserRuleCall_0() { return cSetLiteralParserRuleCall_0; }

		//"(" SetAddition ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//SetAddition
		public RuleCall getSetAdditionParserRuleCall_1_1() { return cSetAdditionParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class SetLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SetLiteral");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSetParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRangeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSetConstructParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLIDTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//SetLiteral returns SetExpression:
		//	Set | Range | SetConstruct | LID;
		public ParserRule getRule() { return rule; }

		//Set | Range | SetConstruct | LID
		public Alternatives getAlternatives() { return cAlternatives; }

		//Set
		public RuleCall getSetParserRuleCall_0() { return cSetParserRuleCall_0; }

		//Range
		public RuleCall getRangeParserRuleCall_1() { return cRangeParserRuleCall_1; }

		//SetConstruct
		public RuleCall getSetConstructParserRuleCall_2() { return cSetConstructParserRuleCall_2; }

		//LID
		public RuleCall getLIDTerminalRuleCall_3() { return cLIDTerminalRuleCall_3; }
	}

	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPredicateAtomParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBuiltInAtomParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//// 1.8 Atoms, 1.14.4 Atoms
		//Atom:
		//	PredicateAtom | BuiltInAtom;
		public ParserRule getRule() { return rule; }

		//PredicateAtom | BuiltInAtom
		public Alternatives getAlternatives() { return cAlternatives; }

		//PredicateAtom
		public RuleCall getPredicateAtomParserRuleCall_0() { return cPredicateAtomParserRuleCall_0; }

		//BuiltInAtom
		public RuleCall getBuiltInAtomParserRuleCall_1() { return cBuiltInAtomParserRuleCall_1; }
	}

	public class PredicateAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PredicateAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFidAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFidLIDTerminalRuleCall_0_0 = (RuleCall)cFidAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsTermsParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PredicateAtom:
		//	fid=LID ("(" terms=Terms ")")?;
		public ParserRule getRule() { return rule; }

		//fid=LID ("(" terms=Terms ")")?
		public Group getGroup() { return cGroup; }

		//fid=LID
		public Assignment getFidAssignment_0() { return cFidAssignment_0; }

		//LID
		public RuleCall getFidLIDTerminalRuleCall_0_0() { return cFidLIDTerminalRuleCall_0_0; }

		//("(" terms=Terms ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//terms=Terms
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }

		//Terms
		public RuleCall getTermsTermsParserRuleCall_1_1_0() { return cTermsTermsParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class BasicPredicateAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BasicPredicateAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFidAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFidLIDTerminalRuleCall_0_0 = (RuleCall)cFidAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cTermsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermsBasicTermsParserRuleCall_1_1_0 = (RuleCall)cTermsAssignment_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//BasicPredicateAtom:
		//	fid=LID ("(" terms=BasicTerms ")")?;
		public ParserRule getRule() { return rule; }

		//fid=LID ("(" terms=BasicTerms ")")?
		public Group getGroup() { return cGroup; }

		//fid=LID
		public Assignment getFidAssignment_0() { return cFidAssignment_0; }

		//LID
		public RuleCall getFidLIDTerminalRuleCall_0_0() { return cFidLIDTerminalRuleCall_0_0; }

		//("(" terms=BasicTerms ")")?
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//terms=BasicTerms
		public Assignment getTermsAssignment_1_1() { return cTermsAssignment_1_1; }

		//BasicTerms
		public RuleCall getTermsBasicTermsParserRuleCall_1_1_0() { return cTermsBasicTermsParserRuleCall_1_1_0; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class BuiltInAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "BuiltInAtom");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBasicTermParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpAtomOpParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRhsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRhsBasicTermParserRuleCall_2_0 = (RuleCall)cRhsAssignment_2.eContents().get(0);
		
		//BuiltInAtom:
		//	lhs=BasicTerm op=AtomOp rhs=BasicTerm;
		public ParserRule getRule() { return rule; }

		//lhs=BasicTerm op=AtomOp rhs=BasicTerm
		public Group getGroup() { return cGroup; }

		//lhs=BasicTerm
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//BasicTerm
		public RuleCall getLhsBasicTermParserRuleCall_0_0() { return cLhsBasicTermParserRuleCall_0_0; }

		//op=AtomOp
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }

		//AtomOp
		public RuleCall getOpAtomOpParserRuleCall_1_0() { return cOpAtomOpParserRuleCall_1_0; }

		//rhs=BasicTerm
		public Assignment getRhsAssignment_2() { return cRhsAssignment_2; }

		//BasicTerm
		public RuleCall getRhsBasicTermParserRuleCall_2_0() { return cRhsBasicTermParserRuleCall_2_0; }
	}

	public class AtomOpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AtomOp");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cGreaterThanSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cGreaterThanSignEqualsSignKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLessThanSignEqualsSignKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cExclamationMarkEqualsSignKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		
		//// note <> not used in 1.14.4
		//AtomOp:
		//	">" | "<" | ">=" | "<=" | "=" | "!=";
		public ParserRule getRule() { return rule; }

		//">" | "<" | ">=" | "<=" | "=" | "!="
		public Alternatives getAlternatives() { return cAlternatives; }

		//">"
		public Keyword getGreaterThanSignKeyword_0() { return cGreaterThanSignKeyword_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1() { return cLessThanSignKeyword_1; }

		//">="
		public Keyword getGreaterThanSignEqualsSignKeyword_2() { return cGreaterThanSignEqualsSignKeyword_2; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_3() { return cLessThanSignEqualsSignKeyword_3; }

		//"="
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }

		//"!="
		public Keyword getExclamationMarkEqualsSignKeyword_5() { return cExclamationMarkEqualsSignKeyword_5; }
	}

	public class SentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Sentence");
		private final RuleCall cOrSentenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Sentences: 1.9. grammar section 1.14.5
		//Sentence: // | AndSentence | NotSentence
		//	OrSentence;
		public ParserRule getRule() { return rule; }

		//// | AndSentence | NotSentence
		//OrSentence
		public RuleCall getOrSentenceParserRuleCall() { return cOrSentenceParserRuleCall; }
	}

	public class OrSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// our left-factored version of the left-recursive grammar from specification
		//OrSentence returns SentenceExpr:
		//	AndSentence ({OrSentence.left=current} "or" right=AndSentence)* // right=OrSentence
		//;
		public ParserRule getRule() { return rule; }

		//AndSentence ({OrSentence.left=current} "or" right=AndSentence)* // right=OrSentence
		public Group getGroup() { return cGroup; }

		//AndSentence
		public RuleCall getAndSentenceParserRuleCall_0() { return cAndSentenceParserRuleCall_0; }

		//({OrSentence.left=current} "or" right=AndSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{OrSentence.left=current}
		public Action getOrSentenceLeftAction_1_0() { return cOrSentenceLeftAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//right=AndSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndSentence
		public RuleCall getRightAndSentenceParserRuleCall_1_2_0() { return cRightAndSentenceParserRuleCall_1_2_0; }
	}

	public class AndSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNotSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Alternatives cAlternatives_1_1 = (Alternatives)cGroup_1.eContents().get(1);
		private final Keyword cAndKeyword_1_1_0 = (Keyword)cAlternatives_1_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_1_1 = (Keyword)cAlternatives_1_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightNotSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndSentence returns SentenceExpr:
		//	NotSentence ({AndSentence.left=current} ("and" | ",") right=NotSentence)* // right=AndSentence
		//;
		public ParserRule getRule() { return rule; }

		//NotSentence ({AndSentence.left=current} ("and" | ",") right=NotSentence)* // right=AndSentence
		public Group getGroup() { return cGroup; }

		//NotSentence
		public RuleCall getNotSentenceParserRuleCall_0() { return cNotSentenceParserRuleCall_0; }

		//({AndSentence.left=current} ("and" | ",") right=NotSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{AndSentence.left=current}
		public Action getAndSentenceLeftAction_1_0() { return cAndSentenceLeftAction_1_0; }

		//"and" | ","
		public Alternatives getAlternatives_1_1() { return cAlternatives_1_1; }

		//"and"
		public Keyword getAndKeyword_1_1_0() { return cAndKeyword_1_1_0; }

		//","
		public Keyword getCommaKeyword_1_1_1() { return cCommaKeyword_1_1_1; }

		//right=NotSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//NotSentence
		public RuleCall getRightNotSentenceParserRuleCall_1_2_0() { return cRightNotSentenceParserRuleCall_1_2_0; }
	}

	public class NotSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "NotSentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPrimarySentenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPrimarySentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//NotSentence returns SentenceExpr:
		//	PrimarySentence | "not" PrimarySentence;
		public ParserRule getRule() { return rule; }

		//PrimarySentence | "not" PrimarySentence
		public Alternatives getAlternatives() { return cAlternatives; }

		//PrimarySentence
		public RuleCall getPrimarySentenceParserRuleCall_0() { return cPrimarySentenceParserRuleCall_0; }

		//"not" PrimarySentence
		public Group getGroup_1() { return cGroup_1; }

		//"not"
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//PrimarySentence
		public RuleCall getPrimarySentenceParserRuleCall_1_1() { return cPrimarySentenceParserRuleCall_1_1; }
	}

	public class PrimarySentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "PrimarySentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSentenceLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOrSentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//PrimarySentence returns SentenceExpr:
		//	SentenceLiteral | "(" OrSentence ")";
		public ParserRule getRule() { return rule; }

		//SentenceLiteral | "(" OrSentence ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//SentenceLiteral
		public RuleCall getSentenceLiteralParserRuleCall_0() { return cSentenceLiteralParserRuleCall_0; }

		//"(" OrSentence ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//OrSentence
		public RuleCall getOrSentenceParserRuleCall_1_1() { return cOrSentenceParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class SentenceLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "SentenceLiteral");
		private final RuleCall cAtomParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//SentenceLiteral:
		//	Atom;
		public ParserRule getRule() { return rule; }

		//Atom
		public RuleCall getAtomParserRuleCall() { return cAtomParserRuleCall; }
	}

	public class PSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pSentence");
		private final RuleCall cPOrSentenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// Predicate Sentences 
		//pSentence:
		//	pOrSentence;
		public ParserRule getRule() { return rule; }

		//pOrSentence
		public RuleCall getPOrSentenceParserRuleCall() { return cPOrSentenceParserRuleCall; }
	}

	public class POrSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pOrSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPAndSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPOrSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cOrKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPAndSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// our left-factored version of the left-recursive grammar from specification
		//pOrSentence returns SentenceExpr:
		//	pAndSentence ({pOrSentence.left=current} "or" right=pAndSentence)* // right=OrSentence
		//;
		public ParserRule getRule() { return rule; }

		//pAndSentence ({pOrSentence.left=current} "or" right=pAndSentence)* // right=OrSentence
		public Group getGroup() { return cGroup; }

		//pAndSentence
		public RuleCall getPAndSentenceParserRuleCall_0() { return cPAndSentenceParserRuleCall_0; }

		//({pOrSentence.left=current} "or" right=pAndSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{pOrSentence.left=current}
		public Action getPOrSentenceLeftAction_1_0() { return cPOrSentenceLeftAction_1_0; }

		//"or"
		public Keyword getOrKeyword_1_1() { return cOrKeyword_1_1; }

		//right=pAndSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//pAndSentence
		public RuleCall getRightPAndSentenceParserRuleCall_1_2_0() { return cRightPAndSentenceParserRuleCall_1_2_0; }
	}

	public class PAndSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pAndSentence");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPNotSentenceParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPAndSentenceLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAndKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPNotSentenceParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//pAndSentence returns SentenceExpr:
		//	pNotSentence ({pAndSentence.left=current} "and" right=pNotSentence)* // right=AndSentence
		//;
		public ParserRule getRule() { return rule; }

		//pNotSentence ({pAndSentence.left=current} "and" right=pNotSentence)* // right=AndSentence
		public Group getGroup() { return cGroup; }

		//pNotSentence
		public RuleCall getPNotSentenceParserRuleCall_0() { return cPNotSentenceParserRuleCall_0; }

		//({pAndSentence.left=current} "and" right=pNotSentence)*
		public Group getGroup_1() { return cGroup_1; }

		//{pAndSentence.left=current}
		public Action getPAndSentenceLeftAction_1_0() { return cPAndSentenceLeftAction_1_0; }

		//"and"
		public Keyword getAndKeyword_1_1() { return cAndKeyword_1_1; }

		//right=pNotSentence
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//pNotSentence
		public RuleCall getRightPNotSentenceParserRuleCall_1_2_0() { return cRightPNotSentenceParserRuleCall_1_2_0; }
	}

	public class PNotSentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pNotSentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPPrimarySentenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cNotKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cPPrimarySentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//pNotSentence returns SentenceExpr:
		//	pPrimarySentence | "not" pPrimarySentence;
		public ParserRule getRule() { return rule; }

		//pPrimarySentence | "not" pPrimarySentence
		public Alternatives getAlternatives() { return cAlternatives; }

		//pPrimarySentence
		public RuleCall getPPrimarySentenceParserRuleCall_0() { return cPPrimarySentenceParserRuleCall_0; }

		//"not" pPrimarySentence
		public Group getGroup_1() { return cGroup_1; }

		//"not"
		public Keyword getNotKeyword_1_0() { return cNotKeyword_1_0; }

		//pPrimarySentence
		public RuleCall getPPrimarySentenceParserRuleCall_1_1() { return cPPrimarySentenceParserRuleCall_1_1; }
	}

	public class PPrimarySentenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pPrimarySentence");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPSentenceLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cOrSentenceParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//pPrimarySentence returns SentenceExpr:
		//	pSentenceLiteral | "(" OrSentence ")";
		public ParserRule getRule() { return rule; }

		//pSentenceLiteral | "(" OrSentence ")"
		public Alternatives getAlternatives() { return cAlternatives; }

		//pSentenceLiteral
		public RuleCall getPSentenceLiteralParserRuleCall_0() { return cPSentenceLiteralParserRuleCall_0; }

		//"(" OrSentence ")"
		public Group getGroup_1() { return cGroup_1; }

		//"("
		public Keyword getLeftParenthesisKeyword_1_0() { return cLeftParenthesisKeyword_1_0; }

		//OrSentence
		public RuleCall getOrSentenceParserRuleCall_1_1() { return cOrSentenceParserRuleCall_1_1; }

		//")"
		public Keyword getRightParenthesisKeyword_1_2() { return cRightParenthesisKeyword_1_2; }
	}

	public class PSentenceLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "pSentenceLiteral");
		private final RuleCall cPredicateAtomParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//pSentenceLiteral:
		//	PredicateAtom;
		public ParserRule getRule() { return rule; }

		//PredicateAtom
		public RuleCall getPredicateAtomParserRuleCall() { return cPredicateAtomParserRuleCall; }
	}

	public class MaybeLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MaybeLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMaybeKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cBasicPredicateAtomParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// 1.10 Maybe Literals, 1.14.5 Maybe Literals
		//MaybeLiteral:
		//	"maybe" BasicPredicateAtom;
		public ParserRule getRule() { return rule; }

		//"maybe" BasicPredicateAtom
		public Group getGroup() { return cGroup; }

		//"maybe"
		public Keyword getMaybeKeyword_0() { return cMaybeKeyword_0; }

		//BasicPredicateAtom
		public RuleCall getBasicPredicateAtomParserRuleCall_1() { return cBasicPredicateAtomParserRuleCall_1; }
	}

	public class CardinalityConstraintElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "CardinalityConstraint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLhsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLhsBoundParserRuleCall_0_0 = (RuleCall)cLhsAssignment_0.eContents().get(0);
		private final Keyword cLessThanSignEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cAtomAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cAtomBasicPredicateAtomParserRuleCall_4_0 = (RuleCall)cAtomAssignment_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Keyword cVerticalLineKeyword_6 = (Keyword)cGroup.eContents().get(6);
		private final Keyword cLessThanSignEqualsSignKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cRhsAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cRhsBoundParserRuleCall_8_0 = (RuleCall)cRhsAssignment_8.eContents().get(0);
		
		//// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
		//CardinalityConstraint:
		//	lhs=Bound "<=" "|" "{" atom=BasicPredicateAtom "}" "|" "<=" rhs=Bound;
		public ParserRule getRule() { return rule; }

		//lhs=Bound "<=" "|" "{" atom=BasicPredicateAtom "}" "|" "<=" rhs=Bound
		public Group getGroup() { return cGroup; }

		//lhs=Bound
		public Assignment getLhsAssignment_0() { return cLhsAssignment_0; }

		//Bound
		public RuleCall getLhsBoundParserRuleCall_0_0() { return cLhsBoundParserRuleCall_0_0; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_1() { return cLessThanSignEqualsSignKeyword_1; }

		//"|"
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_3() { return cLeftCurlyBracketKeyword_3; }

		//atom=BasicPredicateAtom
		public Assignment getAtomAssignment_4() { return cAtomAssignment_4; }

		//BasicPredicateAtom
		public RuleCall getAtomBasicPredicateAtomParserRuleCall_4_0() { return cAtomBasicPredicateAtomParserRuleCall_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_5() { return cRightCurlyBracketKeyword_5; }

		//"|"
		public Keyword getVerticalLineKeyword_6() { return cVerticalLineKeyword_6; }

		//"<="
		public Keyword getLessThanSignEqualsSignKeyword_7() { return cLessThanSignEqualsSignKeyword_7; }

		//rhs=Bound
		public Assignment getRhsAssignment_8() { return cRhsAssignment_8; }

		//Bound
		public RuleCall getRhsBoundParserRuleCall_8_0() { return cRhsBoundParserRuleCall_8_0; }
	}

	public class BoundElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Bound");
		private final Assignment cAvAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cAvArithmeticTermParserRuleCall_0 = (RuleCall)cAvAssignment.eContents().get(0);
		
		//Bound: // av=ArithmeticTerm | iv=INT | cv=NumericConstant
		//	av= // | cv=NumericConstant | id=ID
		//	ArithmeticTerm;
		public ParserRule getRule() { return rule; }

		//// av=ArithmeticTerm | iv=INT | cv=NumericConstant
		//av= // | cv=NumericConstant | id=ID
		//ArithmeticTerm
		public Assignment getAvAssignment() { return cAvAssignment; }

		//// | cv=NumericConstant | id=ID
		//ArithmeticTerm
		public RuleCall getAvArithmeticTermParserRuleCall_0() { return cAvArithmeticTermParserRuleCall_0; }
	}

	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cHeadAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cHeadHeadParserRuleCall_0_0 = (RuleCall)cHeadAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cConditionAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final Keyword cConditionIfKeyword_1_0_0 = (Keyword)cConditionAssignment_1_0.eContents().get(0);
		private final Assignment cBodyAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cBodySentenceParserRuleCall_1_1_0 = (RuleCall)cBodyAssignment_1_1.eContents().get(0);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// 1.12 Rules, 1.14.8 Rules
		//Rule:
		//	head=Head (condition="if" body=Sentence)? ".";
		public ParserRule getRule() { return rule; }

		//head=Head (condition="if" body=Sentence)? "."
		public Group getGroup() { return cGroup; }

		//head=Head
		public Assignment getHeadAssignment_0() { return cHeadAssignment_0; }

		//Head
		public RuleCall getHeadHeadParserRuleCall_0_0() { return cHeadHeadParserRuleCall_0_0; }

		//(condition="if" body=Sentence)?
		public Group getGroup_1() { return cGroup_1; }

		//condition="if"
		public Assignment getConditionAssignment_1_0() { return cConditionAssignment_1_0; }

		//"if"
		public Keyword getConditionIfKeyword_1_0_0() { return cConditionIfKeyword_1_0_0; }

		//body=Sentence
		public Assignment getBodyAssignment_1_1() { return cBodyAssignment_1_1; }

		//Sentence
		public RuleCall getBodySentenceParserRuleCall_1_1_0() { return cBodySentenceParserRuleCall_1_1_0; }

		//"."
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
	}

	public class HeadElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Head");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPSentenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMaybeLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cCardinalityConstraintParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Head:
		//	pSentence | MaybeLiteral | CardinalityConstraint;
		public ParserRule getRule() { return rule; }

		//pSentence | MaybeLiteral | CardinalityConstraint
		public Alternatives getAlternatives() { return cAlternatives; }

		//pSentence
		public RuleCall getPSentenceParserRuleCall_0() { return cPSentenceParserRuleCall_0; }

		//MaybeLiteral
		public RuleCall getMaybeLiteralParserRuleCall_1() { return cMaybeLiteralParserRuleCall_1; }

		//CardinalityConstraint
		public RuleCall getCardinalityConstraintParserRuleCall_2() { return cCardinalityConstraintParserRuleCall_2; }
	}

	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRuleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cTypeDeclarationParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantDeclarationParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// 1.13 Program, 1.14.9 Program
		//// by 1.14.9 a program consists of const_decls, type_decls, and rules
		//// these are our statements
		//// 1.15 Comments
		//// by default the generated editor will enable / * * / and // comments
		//Statement:
		//	Rule | TypeDeclaration | ConstantDeclaration;
		public ParserRule getRule() { return rule; }

		//Rule | TypeDeclaration | ConstantDeclaration
		public Alternatives getAlternatives() { return cAlternatives; }

		//Rule
		public RuleCall getRuleParserRuleCall_0() { return cRuleParserRuleCall_0; }

		//TypeDeclaration
		public RuleCall getTypeDeclarationParserRuleCall_1() { return cTypeDeclarationParserRuleCall_1; }

		//ConstantDeclaration
		public RuleCall getConstantDeclarationParserRuleCall_2() { return cConstantDeclarationParserRuleCall_2; }
	}
	
	
	private final ProgramElements pProgram;
	private final TerminalRule tLID;
	private final TerminalRule tUID;
	private final BasicTermElements pBasicTerm;
	private final NumericConstantElements pNumericConstant;
	private final VariableElements pVariable;
	private final TypedVariableElements pTypedVariable;
	private final ArithmeticTermElements pArithmeticTerm;
	private final AdditionElements pAddition;
	private final MultiplicationElements pMultiplication;
	private final PrimaryElements pPrimary;
	private final ArithmeticLiteralElements pArithmeticLiteral;
	private final GroundArithmeticTermElements pGroundArithmeticTerm;
	private final GroundAdditionElements pGroundAddition;
	private final GroundMultiplicationElements pGroundMultiplication;
	private final GroundPrimaryElements pGroundPrimary;
	private final GroundArithmeticLiteralElements pGroundArithmeticLiteral;
	private final FunctionalTermElements pFunctionalTerm;
	private final GroundFunctionalTermElements pGroundFunctionalTerm;
	private final BasicTermsElements pBasicTerms;
	private final GroundTermsElements pGroundTerms;
	private final GroundTermElements pGroundTerm;
	private final QuantifiedTermElements pQuantifiedTerm;
	private final QuantifierElements pQuantifier;
	private final TermElements pTerm;
	private final TermsElements pTerms;
	private final ConstantDeclarationElements pConstantDeclaration;
	private final TypeDeclarationElements pTypeDeclaration;
	private final LimitElements pLimit;
	private final SetElements pSet;
	private final RangeElements pRange;
	private final SetExpressionElements pSetExpression;
	private final SetConstructElements pSetConstruct;
	private final TVarsElements pTVars;
	private final TVarElements pTVar;
	private final SetAdditionElements pSetAddition;
	private final SetMultiplicationElements pSetMultiplication;
	private final SetPrimaryElements pSetPrimary;
	private final SetLiteralElements pSetLiteral;
	private final AtomElements pAtom;
	private final PredicateAtomElements pPredicateAtom;
	private final BasicPredicateAtomElements pBasicPredicateAtom;
	private final BuiltInAtomElements pBuiltInAtom;
	private final AtomOpElements pAtomOp;
	private final SentenceElements pSentence;
	private final OrSentenceElements pOrSentence;
	private final AndSentenceElements pAndSentence;
	private final NotSentenceElements pNotSentence;
	private final PrimarySentenceElements pPrimarySentence;
	private final SentenceLiteralElements pSentenceLiteral;
	private final PSentenceElements pPSentence;
	private final POrSentenceElements pPOrSentence;
	private final PAndSentenceElements pPAndSentence;
	private final PNotSentenceElements pPNotSentence;
	private final PPrimarySentenceElements pPPrimarySentence;
	private final PSentenceLiteralElements pPSentenceLiteral;
	private final MaybeLiteralElements pMaybeLiteral;
	private final CardinalityConstraintElements pCardinalityConstraint;
	private final BoundElements pBound;
	private final RuleElements pRule;
	private final HeadElements pHead;
	private final StatementElements pStatement;
	
	private final Grammar grammar;

	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public LGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pProgram = new ProgramElements();
		this.tLID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "LID");
		this.tUID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "UID");
		this.pBasicTerm = new BasicTermElements();
		this.pNumericConstant = new NumericConstantElements();
		this.pVariable = new VariableElements();
		this.pTypedVariable = new TypedVariableElements();
		this.pArithmeticTerm = new ArithmeticTermElements();
		this.pAddition = new AdditionElements();
		this.pMultiplication = new MultiplicationElements();
		this.pPrimary = new PrimaryElements();
		this.pArithmeticLiteral = new ArithmeticLiteralElements();
		this.pGroundArithmeticTerm = new GroundArithmeticTermElements();
		this.pGroundAddition = new GroundAdditionElements();
		this.pGroundMultiplication = new GroundMultiplicationElements();
		this.pGroundPrimary = new GroundPrimaryElements();
		this.pGroundArithmeticLiteral = new GroundArithmeticLiteralElements();
		this.pFunctionalTerm = new FunctionalTermElements();
		this.pGroundFunctionalTerm = new GroundFunctionalTermElements();
		this.pBasicTerms = new BasicTermsElements();
		this.pGroundTerms = new GroundTermsElements();
		this.pGroundTerm = new GroundTermElements();
		this.pQuantifiedTerm = new QuantifiedTermElements();
		this.pQuantifier = new QuantifierElements();
		this.pTerm = new TermElements();
		this.pTerms = new TermsElements();
		this.pConstantDeclaration = new ConstantDeclarationElements();
		this.pTypeDeclaration = new TypeDeclarationElements();
		this.pLimit = new LimitElements();
		this.pSet = new SetElements();
		this.pRange = new RangeElements();
		this.pSetExpression = new SetExpressionElements();
		this.pSetConstruct = new SetConstructElements();
		this.pTVars = new TVarsElements();
		this.pTVar = new TVarElements();
		this.pSetAddition = new SetAdditionElements();
		this.pSetMultiplication = new SetMultiplicationElements();
		this.pSetPrimary = new SetPrimaryElements();
		this.pSetLiteral = new SetLiteralElements();
		this.pAtom = new AtomElements();
		this.pPredicateAtom = new PredicateAtomElements();
		this.pBasicPredicateAtom = new BasicPredicateAtomElements();
		this.pBuiltInAtom = new BuiltInAtomElements();
		this.pAtomOp = new AtomOpElements();
		this.pSentence = new SentenceElements();
		this.pOrSentence = new OrSentenceElements();
		this.pAndSentence = new AndSentenceElements();
		this.pNotSentence = new NotSentenceElements();
		this.pPrimarySentence = new PrimarySentenceElements();
		this.pSentenceLiteral = new SentenceLiteralElements();
		this.pPSentence = new PSentenceElements();
		this.pPOrSentence = new POrSentenceElements();
		this.pPAndSentence = new PAndSentenceElements();
		this.pPNotSentence = new PNotSentenceElements();
		this.pPPrimarySentence = new PPrimarySentenceElements();
		this.pPSentenceLiteral = new PSentenceLiteralElements();
		this.pMaybeLiteral = new MaybeLiteralElements();
		this.pCardinalityConstraint = new CardinalityConstraintElements();
		this.pBound = new BoundElements();
		this.pRule = new RuleElements();
		this.pHead = new HeadElements();
		this.pStatement = new StatementElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("net.certware.argument.language.L".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// basic model is the program of section 1.13
	//Program:
	//	statements+=Statement*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}

	//// identifier with first character lower
	//terminal LID:
	//	"a".."z" ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getLIDRule() {
		return tLID;
	} 

	//// identifier with first character upper
	//terminal UID:
	//	"A".."Z" ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getUIDRule() {
		return tUID;
	} 

	//// 1.1 Symbols
	////Symbol:
	////	IntegerNumeral |
	////	Identifier |
	////	SpecialCharacter
	////;
	//// IntegerNumeral:  MRB replaced with direct substitution of terminal INT
	////	INT // provided by Terminals and returning ECore Integer type 
	//// ;
	//// Identifier:  MRB replaced with direct substitution of terminal ID
	////	ID // provided by Terminals and returning ECore String type
	////;
	////SpecialCharacter:
	////	'>' | '=' | '>' | '+' | '-' | '*' | '{' | '}' | '(' | ')' | ',' | '.' | '|'	
	////;
	//// 1.2 Basic Terms, 1.14.1 Terms
	//BasicTerm: // NumericConstant |    // INT  covered by ArithmeticTerm
	//// Variable |           // UID  covered by ArithmeticTerm
	//	TypedVariable // ID UID
	//	// Addition | Multiplication
	//	| ArithmeticTerm | // ID ( BasicTerms )
	//	FunctionalTerm;
	public BasicTermElements getBasicTermAccess() {
		return pBasicTerm;
	}
	
	public ParserRule getBasicTermRule() {
		return getBasicTermAccess().getRule();
	}

	//NumericConstant:
	//	value=INT;
	public NumericConstantElements getNumericConstantAccess() {
		return pNumericConstant;
	}
	
	public ParserRule getNumericConstantRule() {
		return getNumericConstantAccess().getRule();
	}

	//Variable:
	//	identifier=UID;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}

	//TypedVariable:
	//	type=LID var=Variable;
	public TypedVariableElements getTypedVariableAccess() {
		return pTypedVariable;
	}
	
	public ParserRule getTypedVariableRule() {
		return getTypedVariableAccess().getRule();
	}

	//// our version of a left-factored equivalent of the recursive grammar from the spec
	//ArithmeticTerm:
	//	Addition;
	public ArithmeticTermElements getArithmeticTermAccess() {
		return pArithmeticTerm;
	}
	
	public ParserRule getArithmeticTermRule() {
		return getArithmeticTermAccess().getRule();
	}

	//Addition returns ArithmeticTerm:
	//	Multiplication ({Addition.lhs=current} ("+" | "-") rhs=Multiplication)*;
	public AdditionElements getAdditionAccess() {
		return pAddition;
	}
	
	public ParserRule getAdditionRule() {
		return getAdditionAccess().getRule();
	}

	//Multiplication returns ArithmeticTerm:
	//	Primary ({Multiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*;
	public MultiplicationElements getMultiplicationAccess() {
		return pMultiplication;
	}
	
	public ParserRule getMultiplicationRule() {
		return getMultiplicationAccess().getRule();
	}

	//Primary returns ArithmeticTerm:
	//	minus="-"? term=ArithmeticLiteral | minus="-"? "(" term=Addition ")";
	public PrimaryElements getPrimaryAccess() {
		return pPrimary;
	}
	
	public ParserRule getPrimaryRule() {
		return getPrimaryAccess().getRule();
	}

	//ArithmeticLiteral:
	//	v=Variable // UID
	//	//CONST
	//	| tv=TypedVariable | const=LID | value=INT;
	public ArithmeticLiteralElements getArithmeticLiteralAccess() {
		return pArithmeticLiteral;
	}
	
	public ParserRule getArithmeticLiteralRule() {
		return getArithmeticLiteralAccess().getRule();
	}

	//// ground arithmetic term from 1.2 and  1.14.1, 
	//// reuse the definition of Arithmetic Term
	//GroundArithmeticTerm:
	//	GroundAddition;
	public GroundArithmeticTermElements getGroundArithmeticTermAccess() {
		return pGroundArithmeticTerm;
	}
	
	public ParserRule getGroundArithmeticTermRule() {
		return getGroundArithmeticTermAccess().getRule();
	}

	//GroundAddition returns ArithmeticTerm:
	//	GroundMultiplication ({GroundAddition.lhs=current} ("+" | "-") rhs=GroundMultiplication)*;
	public GroundAdditionElements getGroundAdditionAccess() {
		return pGroundAddition;
	}
	
	public ParserRule getGroundAdditionRule() {
		return getGroundAdditionAccess().getRule();
	}

	//GroundMultiplication returns ArithmeticTerm:
	//	GroundPrimary ({GroundMultiplication.lhs=current} ("*" | "/" | "%") rhs=Primary)*;
	public GroundMultiplicationElements getGroundMultiplicationAccess() {
		return pGroundMultiplication;
	}
	
	public ParserRule getGroundMultiplicationRule() {
		return getGroundMultiplicationAccess().getRule();
	}

	//GroundPrimary returns ArithmeticTerm:
	//	minus="-"? term=GroundArithmeticLiteral | minus="-"? "(" term=Addition ")";
	public GroundPrimaryElements getGroundPrimaryAccess() {
		return pGroundPrimary;
	}
	
	public ParserRule getGroundPrimaryRule() {
		return getGroundPrimaryAccess().getRule();
	}

	//GroundArithmeticLiteral:
	//	identifier=LID | value=INT;
	public GroundArithmeticLiteralElements getGroundArithmeticLiteralAccess() {
		return pGroundArithmeticLiteral;
	}
	
	public ParserRule getGroundArithmeticLiteralRule() {
		return getGroundArithmeticLiteralAccess().getRule();
	}

	//FunctionalTerm: // ID'('terms+=BasicTerm+')'
	//	LID "(" Terms ")";
	public FunctionalTermElements getFunctionalTermAccess() {
		return pFunctionalTerm;
	}
	
	public ParserRule getFunctionalTermRule() {
		return getFunctionalTermAccess().getRule();
	}

	//GroundFunctionalTerm: // ID'('terms+=BasicTerm+')'
	//	LID "(" GroundTerms ")";
	public GroundFunctionalTermElements getGroundFunctionalTermAccess() {
		return pGroundFunctionalTerm;
	}
	
	public ParserRule getGroundFunctionalTermRule() {
		return getGroundFunctionalTermAccess().getRule();
	}

	//BasicTerms:
	//	car=BasicTerm ("," cdr+=BasicTerm)*;
	public BasicTermsElements getBasicTermsAccess() {
		return pBasicTerms;
	}
	
	public ParserRule getBasicTermsRule() {
		return getBasicTermsAccess().getRule();
	}

	//GroundTerms:
	//	car=GroundTerm ("," cdr+=GroundTerm)*;
	public GroundTermsElements getGroundTermsAccess() {
		return pGroundTerms;
	}
	
	public ParserRule getGroundTermsRule() {
		return getGroundTermsAccess().getRule();
	}

	//GroundTerm:
	//	GroundArithmeticTerm | GroundFunctionalTerm;
	public GroundTermElements getGroundTermAccess() {
		return pGroundTerm;
	}
	
	public ParserRule getGroundTermRule() {
		return getGroundTermAccess().getRule();
	}

	//// 1.6 Quantified Terms, 1.14.1 Terms
	//QuantifiedTerm:
	//	Quantifier LID Variable?;
	public QuantifiedTermElements getQuantifiedTermAccess() {
		return pQuantifiedTerm;
	}
	
	public ParserRule getQuantifiedTermRule() {
		return getQuantifiedTermAccess().getRule();
	}

	//Quantifier:
	//	"every" | "some";
	public QuantifierElements getQuantifierAccess() {
		return pQuantifier;
	}
	
	public ParserRule getQuantifierRule() {
		return getQuantifierAccess().getRule();
	}

	//// 1.7 Terms, 1.14.1 Terms
	//Term:
	//	BasicTerm | QuantifiedTerm;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}

	//Terms:
	//	car=Term ("," cdr+=Term)*;
	public TermsElements getTermsAccess() {
		return pTerms;
	}
	
	public ParserRule getTermsRule() {
		return getTermsAccess().getRule();
	}

	//// 1.14.2, 1.3 Constant Declaration
	//ConstantDeclaration:
	//	"const" id=LID "=" // (cv=NumericConstant | iv=INT | av=ArithmeticTerm )
	//	cv=GroundArithmeticTerm ".";
	public ConstantDeclarationElements getConstantDeclarationAccess() {
		return pConstantDeclaration;
	}
	
	public ParserRule getConstantDeclarationRule() {
		return getConstantDeclarationAccess().getRule();
	}

	//// 1.5 Type Declarations, 1.14.3 Type Declarations
	//TypeDeclaration:
	//	"type" id=LID "=" exp=SetExpression ".";
	public TypeDeclarationElements getTypeDeclarationAccess() {
		return pTypeDeclaration;
	}
	
	public ParserRule getTypeDeclarationRule() {
		return getTypeDeclarationAccess().getRule();
	}

	//Limit: //id=ID | 
	//// nc=NumericConstant | at=ArithmeticTerm
	//	cv=GroundArithmeticTerm;
	public LimitElements getLimitAccess() {
		return pLimit;
	}
	
	public ParserRule getLimitRule() {
		return getLimitAccess().getRule();
	}

	//Set:
	//	lhs="{" terms=GroundTerms? "}";
	public SetElements getSetAccess() {
		return pSet;
	}
	
	public ParserRule getSetRule() {
		return getSetAccess().getRule();
	}

	//Range:
	//	"{" lhs=Limit "." "." rhs=Limit "}";
	public RangeElements getRangeAccess() {
		return pRange;
	}
	
	public ParserRule getRangeRule() {
		return getRangeAccess().getRule();
	}

	//SetExpression: // | SetMultiplication
	//	SetAddition;
	public SetExpressionElements getSetExpressionAccess() {
		return pSetExpression;
	}
	
	public ParserRule getSetExpressionRule() {
		return getSetExpressionAccess().getRule();
	}

	//SetConstruct:
	//	lhs=BasicTerm "where" rhs=TVars;
	public SetConstructElements getSetConstructAccess() {
		return pSetConstruct;
	}
	
	public ParserRule getSetConstructRule() {
		return getSetConstructAccess().getRule();
	}

	//TVars:
	//	car=TVar ("," cdr+=TVar)*;
	public TVarsElements getTVarsAccess() {
		return pTVars;
	}
	
	public ParserRule getTVarsRule() {
		return getTVarsAccess().getRule();
	}

	//TVar:
	//	var=Variable "in" id=LID;
	public TVarElements getTVarAccess() {
		return pTVar;
	}
	
	public ParserRule getTVarRule() {
		return getTVarAccess().getRule();
	}

	//SetAddition returns SetExpression:
	//	SetMultiplication ({SetAddition.left=current} "+" right=SetMultiplication)*;
	public SetAdditionElements getSetAdditionAccess() {
		return pSetAddition;
	}
	
	public ParserRule getSetAdditionRule() {
		return getSetAdditionAccess().getRule();
	}

	//SetMultiplication returns SetExpression:
	//	SetPrimary ({SetMultiplication.left=current} ("*" | "\\") right=SetPrimary)*;
	public SetMultiplicationElements getSetMultiplicationAccess() {
		return pSetMultiplication;
	}
	
	public ParserRule getSetMultiplicationRule() {
		return getSetMultiplicationAccess().getRule();
	}

	//SetPrimary returns SetExpression:
	//	SetLiteral | "(" SetAddition ")";
	public SetPrimaryElements getSetPrimaryAccess() {
		return pSetPrimary;
	}
	
	public ParserRule getSetPrimaryRule() {
		return getSetPrimaryAccess().getRule();
	}

	//SetLiteral returns SetExpression:
	//	Set | Range | SetConstruct | LID;
	public SetLiteralElements getSetLiteralAccess() {
		return pSetLiteral;
	}
	
	public ParserRule getSetLiteralRule() {
		return getSetLiteralAccess().getRule();
	}

	//// 1.8 Atoms, 1.14.4 Atoms
	//Atom:
	//	PredicateAtom | BuiltInAtom;
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}

	//PredicateAtom:
	//	fid=LID ("(" terms=Terms ")")?;
	public PredicateAtomElements getPredicateAtomAccess() {
		return pPredicateAtom;
	}
	
	public ParserRule getPredicateAtomRule() {
		return getPredicateAtomAccess().getRule();
	}

	//BasicPredicateAtom:
	//	fid=LID ("(" terms=BasicTerms ")")?;
	public BasicPredicateAtomElements getBasicPredicateAtomAccess() {
		return pBasicPredicateAtom;
	}
	
	public ParserRule getBasicPredicateAtomRule() {
		return getBasicPredicateAtomAccess().getRule();
	}

	//BuiltInAtom:
	//	lhs=BasicTerm op=AtomOp rhs=BasicTerm;
	public BuiltInAtomElements getBuiltInAtomAccess() {
		return pBuiltInAtom;
	}
	
	public ParserRule getBuiltInAtomRule() {
		return getBuiltInAtomAccess().getRule();
	}

	//// note <> not used in 1.14.4
	//AtomOp:
	//	">" | "<" | ">=" | "<=" | "=" | "!=";
	public AtomOpElements getAtomOpAccess() {
		return pAtomOp;
	}
	
	public ParserRule getAtomOpRule() {
		return getAtomOpAccess().getRule();
	}

	//// Sentences: 1.9. grammar section 1.14.5
	//Sentence: // | AndSentence | NotSentence
	//	OrSentence;
	public SentenceElements getSentenceAccess() {
		return pSentence;
	}
	
	public ParserRule getSentenceRule() {
		return getSentenceAccess().getRule();
	}

	//// our left-factored version of the left-recursive grammar from specification
	//OrSentence returns SentenceExpr:
	//	AndSentence ({OrSentence.left=current} "or" right=AndSentence)* // right=OrSentence
	//;
	public OrSentenceElements getOrSentenceAccess() {
		return pOrSentence;
	}
	
	public ParserRule getOrSentenceRule() {
		return getOrSentenceAccess().getRule();
	}

	//AndSentence returns SentenceExpr:
	//	NotSentence ({AndSentence.left=current} ("and" | ",") right=NotSentence)* // right=AndSentence
	//;
	public AndSentenceElements getAndSentenceAccess() {
		return pAndSentence;
	}
	
	public ParserRule getAndSentenceRule() {
		return getAndSentenceAccess().getRule();
	}

	//NotSentence returns SentenceExpr:
	//	PrimarySentence | "not" PrimarySentence;
	public NotSentenceElements getNotSentenceAccess() {
		return pNotSentence;
	}
	
	public ParserRule getNotSentenceRule() {
		return getNotSentenceAccess().getRule();
	}

	//PrimarySentence returns SentenceExpr:
	//	SentenceLiteral | "(" OrSentence ")";
	public PrimarySentenceElements getPrimarySentenceAccess() {
		return pPrimarySentence;
	}
	
	public ParserRule getPrimarySentenceRule() {
		return getPrimarySentenceAccess().getRule();
	}

	//SentenceLiteral:
	//	Atom;
	public SentenceLiteralElements getSentenceLiteralAccess() {
		return pSentenceLiteral;
	}
	
	public ParserRule getSentenceLiteralRule() {
		return getSentenceLiteralAccess().getRule();
	}

	//// Predicate Sentences 
	//pSentence:
	//	pOrSentence;
	public PSentenceElements getPSentenceAccess() {
		return pPSentence;
	}
	
	public ParserRule getPSentenceRule() {
		return getPSentenceAccess().getRule();
	}

	//// our left-factored version of the left-recursive grammar from specification
	//pOrSentence returns SentenceExpr:
	//	pAndSentence ({pOrSentence.left=current} "or" right=pAndSentence)* // right=OrSentence
	//;
	public POrSentenceElements getPOrSentenceAccess() {
		return pPOrSentence;
	}
	
	public ParserRule getPOrSentenceRule() {
		return getPOrSentenceAccess().getRule();
	}

	//pAndSentence returns SentenceExpr:
	//	pNotSentence ({pAndSentence.left=current} "and" right=pNotSentence)* // right=AndSentence
	//;
	public PAndSentenceElements getPAndSentenceAccess() {
		return pPAndSentence;
	}
	
	public ParserRule getPAndSentenceRule() {
		return getPAndSentenceAccess().getRule();
	}

	//pNotSentence returns SentenceExpr:
	//	pPrimarySentence | "not" pPrimarySentence;
	public PNotSentenceElements getPNotSentenceAccess() {
		return pPNotSentence;
	}
	
	public ParserRule getPNotSentenceRule() {
		return getPNotSentenceAccess().getRule();
	}

	//pPrimarySentence returns SentenceExpr:
	//	pSentenceLiteral | "(" OrSentence ")";
	public PPrimarySentenceElements getPPrimarySentenceAccess() {
		return pPPrimarySentence;
	}
	
	public ParserRule getPPrimarySentenceRule() {
		return getPPrimarySentenceAccess().getRule();
	}

	//pSentenceLiteral:
	//	PredicateAtom;
	public PSentenceLiteralElements getPSentenceLiteralAccess() {
		return pPSentenceLiteral;
	}
	
	public ParserRule getPSentenceLiteralRule() {
		return getPSentenceLiteralAccess().getRule();
	}

	//// 1.10 Maybe Literals, 1.14.5 Maybe Literals
	//MaybeLiteral:
	//	"maybe" BasicPredicateAtom;
	public MaybeLiteralElements getMaybeLiteralAccess() {
		return pMaybeLiteral;
	}
	
	public ParserRule getMaybeLiteralRule() {
		return getMaybeLiteralAccess().getRule();
	}

	//// 1.11 Cardinality Constraint, 1.14.7 Cardinality Constraints
	//CardinalityConstraint:
	//	lhs=Bound "<=" "|" "{" atom=BasicPredicateAtom "}" "|" "<=" rhs=Bound;
	public CardinalityConstraintElements getCardinalityConstraintAccess() {
		return pCardinalityConstraint;
	}
	
	public ParserRule getCardinalityConstraintRule() {
		return getCardinalityConstraintAccess().getRule();
	}

	//Bound: // av=ArithmeticTerm | iv=INT | cv=NumericConstant
	//	av= // | cv=NumericConstant | id=ID
	//	ArithmeticTerm;
	public BoundElements getBoundAccess() {
		return pBound;
	}
	
	public ParserRule getBoundRule() {
		return getBoundAccess().getRule();
	}

	//// 1.12 Rules, 1.14.8 Rules
	//Rule:
	//	head=Head (condition="if" body=Sentence)? ".";
	public RuleElements getRuleAccess() {
		return pRule;
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}

	//Head:
	//	pSentence | MaybeLiteral | CardinalityConstraint;
	public HeadElements getHeadAccess() {
		return pHead;
	}
	
	public ParserRule getHeadRule() {
		return getHeadAccess().getRule();
	}

	//// 1.13 Program, 1.14.9 Program
	//// by 1.14.9 a program consists of const_decls, type_decls, and rules
	//// these are our statements
	//// 1.15 Comments
	//// by default the generated editor will enable / * * / and // comments
	//Statement:
	//	Rule | TypeDeclaration | ConstantDeclaration;
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}

	//terminal ID:
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//	"\"" ("\\" . / * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\""))* "\"" | "\'" ("\\" .
	//	/ * 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' * / | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
